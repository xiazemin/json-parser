// Code generated from MarkdownParser.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // MarkdownParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 49, 1110, 
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44, 
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4, 
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55, 
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9, 
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65, 
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4, 
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76, 
	9, 76, 4, 77, 9, 77, 3, 2, 6, 2, 156, 10, 2, 13, 2, 14, 2, 157, 3, 2, 7, 
	2, 161, 10, 2, 12, 2, 14, 2, 164, 11, 2, 3, 2, 5, 2, 167, 10, 2, 3, 3, 
	7, 3, 170, 10, 3, 12, 3, 14, 3, 173, 11, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 189, 10, 
	3, 3, 4, 3, 4, 7, 4, 193, 10, 4, 12, 4, 14, 4, 196, 11, 4, 3, 4, 3, 4, 
	3, 5, 3, 5, 7, 5, 202, 10, 5, 12, 5, 14, 5, 205, 11, 5, 3, 5, 3, 5, 3, 
	6, 3, 6, 5, 6, 211, 10, 6, 3, 7, 3, 7, 5, 7, 215, 10, 7, 3, 8, 3, 8, 6, 
	8, 219, 10, 8, 13, 8, 14, 8, 220, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 6, 9, 228, 
	10, 9, 13, 9, 14, 9, 229, 3, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 6, 10, 
	238, 10, 10, 13, 10, 14, 10, 239, 3, 10, 7, 10, 243, 10, 10, 12, 10, 14, 
	10, 246, 11, 10, 5, 10, 248, 10, 10, 3, 10, 7, 10, 251, 10, 10, 12, 10, 
	14, 10, 254, 11, 10, 5, 10, 256, 10, 10, 3, 10, 5, 10, 259, 10, 10, 3, 
	10, 3, 10, 3, 11, 7, 11, 264, 10, 11, 12, 11, 14, 11, 267, 11, 11, 3, 11, 
	3, 11, 3, 12, 5, 12, 272, 10, 12, 3, 12, 5, 12, 275, 10, 12, 3, 12, 5, 
	12, 278, 10, 12, 3, 13, 3, 13, 5, 13, 282, 10, 13, 3, 13, 7, 13, 285, 10, 
	13, 12, 13, 14, 13, 288, 11, 13, 3, 13, 3, 13, 5, 13, 292, 10, 13, 3, 13, 
	6, 13, 295, 10, 13, 13, 13, 14, 13, 296, 3, 14, 6, 14, 300, 10, 14, 13, 
	14, 14, 14, 301, 3, 15, 3, 15, 7, 15, 306, 10, 15, 12, 15, 14, 15, 309, 
	11, 15, 3, 15, 6, 15, 312, 10, 15, 13, 15, 14, 15, 313, 3, 16, 3, 16, 3, 
	17, 3, 17, 3, 17, 5, 17, 321, 10, 17, 3, 17, 3, 17, 5, 17, 325, 10, 17, 
	3, 17, 3, 17, 5, 17, 329, 10, 17, 3, 17, 7, 17, 332, 10, 17, 12, 17, 14, 
	17, 335, 11, 17, 3, 17, 3, 17, 5, 17, 339, 10, 17, 3, 17, 3, 17, 5, 17, 
	343, 10, 17, 3, 17, 3, 17, 5, 17, 347, 10, 17, 3, 17, 7, 17, 350, 10, 17, 
	12, 17, 14, 17, 353, 11, 17, 3, 17, 3, 17, 5, 17, 357, 10, 17, 3, 17, 3, 
	17, 5, 17, 361, 10, 17, 3, 17, 3, 17, 5, 17, 365, 10, 17, 3, 17, 7, 17, 
	368, 10, 17, 12, 17, 14, 17, 371, 11, 17, 5, 17, 373, 10, 17, 3, 17, 3, 
	17, 3, 17, 5, 17, 378, 10, 17, 3, 18, 6, 18, 381, 10, 18, 13, 18, 14, 18, 
	382, 3, 19, 3, 19, 3, 19, 3, 19, 6, 19, 389, 10, 19, 13, 19, 14, 19, 390, 
	3, 19, 3, 19, 6, 19, 395, 10, 19, 13, 19, 14, 19, 396, 3, 19, 7, 19, 400, 
	10, 19, 12, 19, 14, 19, 403, 11, 19, 3, 19, 3, 19, 7, 19, 407, 10, 19, 
	12, 19, 14, 19, 410, 11, 19, 5, 19, 412, 10, 19, 3, 19, 5, 19, 415, 10, 
	19, 3, 19, 7, 19, 418, 10, 19, 12, 19, 14, 19, 421, 11, 19, 3, 19, 3, 19, 
	3, 20, 3, 20, 3, 20, 3, 20, 3, 21, 6, 21, 430, 10, 21, 13, 21, 14, 21, 
	431, 3, 22, 3, 22, 7, 22, 436, 10, 22, 12, 22, 14, 22, 439, 11, 22, 3, 
	22, 3, 22, 6, 22, 443, 10, 22, 13, 22, 14, 22, 444, 5, 22, 447, 10, 22, 
	3, 23, 3, 23, 3, 23, 5, 23, 452, 10, 23, 3, 24, 3, 24, 7, 24, 456, 10, 
	24, 12, 24, 14, 24, 459, 11, 24, 3, 24, 3, 24, 3, 25, 3, 25, 7, 25, 465, 
	10, 25, 12, 25, 14, 25, 468, 11, 25, 3, 25, 3, 25, 3, 26, 3, 26, 7, 26, 
	474, 10, 26, 12, 26, 14, 26, 477, 11, 26, 3, 26, 3, 26, 3, 27, 3, 27, 6, 
	27, 483, 10, 27, 13, 27, 14, 27, 484, 3, 28, 3, 28, 6, 28, 489, 10, 28, 
	13, 28, 14, 28, 490, 3, 29, 7, 29, 494, 10, 29, 12, 29, 14, 29, 497, 11, 
	29, 3, 29, 7, 29, 500, 10, 29, 12, 29, 14, 29, 503, 11, 29, 3, 29, 6, 29, 
	506, 10, 29, 13, 29, 14, 29, 507, 3, 29, 3, 29, 6, 29, 512, 10, 29, 13, 
	29, 14, 29, 513, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 520, 10, 29, 3, 29, 
	3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 529, 10, 29, 3, 29, 3, 
	29, 3, 29, 3, 29, 7, 29, 535, 10, 29, 12, 29, 14, 29, 538, 11, 29, 3, 29, 
	5, 29, 541, 10, 29, 6, 29, 543, 10, 29, 13, 29, 14, 29, 544, 5, 29, 547, 
	10, 29, 3, 30, 7, 30, 550, 10, 30, 12, 30, 14, 30, 553, 11, 30, 3, 30, 
	7, 30, 556, 10, 30, 12, 30, 14, 30, 559, 11, 30, 3, 30, 3, 30, 6, 30, 563, 
	10, 30, 13, 30, 14, 30, 564, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 571, 10, 
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 580, 10, 30, 
	3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 586, 10, 30, 12, 30, 14, 30, 589, 11, 
	30, 3, 30, 5, 30, 592, 10, 30, 6, 30, 594, 10, 30, 13, 30, 14, 30, 595, 
	5, 30, 598, 10, 30, 3, 31, 3, 31, 6, 31, 602, 10, 31, 13, 31, 14, 31, 603, 
	3, 32, 6, 32, 607, 10, 32, 13, 32, 14, 32, 608, 3, 33, 3, 33, 6, 33, 613, 
	10, 33, 13, 33, 14, 33, 614, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 661, 10, 34, 3, 35, 
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 673, 
	10, 35, 3, 36, 3, 36, 5, 36, 677, 10, 36, 3, 37, 3, 37, 3, 37, 6, 37, 682, 
	10, 37, 13, 37, 14, 37, 683, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 6, 38, 
	691, 10, 38, 13, 38, 14, 38, 692, 3, 38, 3, 38, 3, 39, 3, 39, 5, 39, 699, 
	10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 6, 40, 705, 10, 40, 13, 40, 14, 40, 
	706, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 6, 41, 716, 10, 41, 
	13, 41, 14, 41, 717, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3, 43, 3, 
	43, 3, 43, 5, 43, 729, 10, 43, 3, 44, 3, 44, 3, 44, 6, 44, 734, 10, 44, 
	13, 44, 14, 44, 735, 3, 44, 5, 44, 739, 10, 44, 3, 44, 3, 44, 3, 45, 3, 
	45, 7, 45, 745, 10, 45, 12, 45, 14, 45, 748, 11, 45, 3, 45, 3, 45, 3, 46, 
	3, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 5, 47, 759, 10, 47, 3, 48, 3, 
	48, 6, 48, 763, 10, 48, 13, 48, 14, 48, 764, 3, 48, 3, 48, 3, 49, 3, 49, 
	5, 49, 771, 10, 49, 3, 49, 6, 49, 774, 10, 49, 13, 49, 14, 49, 775, 3, 
	49, 5, 49, 779, 10, 49, 3, 49, 7, 49, 782, 10, 49, 12, 49, 14, 49, 785, 
	11, 49, 3, 49, 3, 49, 3, 50, 6, 50, 790, 10, 50, 13, 50, 14, 50, 791, 3, 
	51, 3, 51, 5, 51, 796, 10, 51, 3, 52, 3, 52, 7, 52, 800, 10, 52, 12, 52, 
	14, 52, 803, 11, 52, 3, 52, 3, 52, 3, 53, 3, 53, 7, 53, 809, 10, 53, 12, 
	53, 14, 53, 812, 11, 53, 3, 53, 3, 53, 3, 54, 5, 54, 817, 10, 54, 3, 54, 
	3, 54, 5, 54, 821, 10, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 
	55, 3, 55, 5, 55, 831, 10, 55, 3, 55, 3, 55, 3, 56, 6, 56, 836, 10, 56, 
	13, 56, 14, 56, 837, 3, 57, 6, 57, 841, 10, 57, 13, 57, 14, 57, 842, 3, 
	58, 6, 58, 846, 10, 58, 13, 58, 14, 58, 847, 3, 59, 3, 59, 3, 59, 3, 60, 
	3, 60, 3, 60, 5, 60, 856, 10, 60, 3, 61, 3, 61, 3, 61, 3, 61, 6, 61, 862, 
	10, 61, 13, 61, 14, 61, 863, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 62, 
	3, 62, 6, 62, 873, 10, 62, 13, 62, 14, 62, 874, 3, 62, 3, 62, 3, 62, 3, 
	63, 3, 63, 3, 63, 3, 63, 3, 63, 6, 63, 885, 10, 63, 13, 63, 14, 63, 886, 
	3, 63, 3, 63, 3, 63, 3, 63, 3, 64, 6, 64, 894, 10, 64, 13, 64, 14, 64, 
	895, 3, 65, 3, 65, 3, 65, 3, 65, 7, 65, 902, 10, 65, 12, 65, 14, 65, 905, 
	11, 65, 3, 65, 3, 65, 3, 66, 3, 66, 3, 66, 3, 66, 7, 66, 913, 10, 66, 12, 
	66, 14, 66, 916, 11, 66, 3, 66, 3, 66, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 
	6, 67, 925, 10, 67, 13, 67, 14, 67, 926, 3, 67, 3, 67, 5, 67, 931, 10, 
	67, 7, 67, 933, 10, 67, 12, 67, 14, 67, 936, 11, 67, 3, 67, 7, 67, 939, 
	10, 67, 12, 67, 14, 67, 942, 11, 67, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 
	3, 68, 3, 68, 3, 68, 7, 68, 952, 10, 68, 12, 68, 14, 68, 955, 11, 68, 3, 
	68, 3, 68, 3, 69, 3, 69, 3, 69, 7, 69, 962, 10, 69, 12, 69, 14, 69, 965, 
	11, 69, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 6, 70, 
	975, 10, 70, 13, 70, 14, 70, 976, 3, 70, 3, 70, 5, 70, 981, 10, 70, 7, 
	70, 983, 10, 70, 12, 70, 14, 70, 986, 11, 70, 3, 70, 7, 70, 989, 10, 70, 
	12, 70, 14, 70, 992, 11, 70, 3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 3, 71, 
	3, 71, 3, 71, 3, 71, 7, 71, 1003, 10, 71, 12, 71, 14, 71, 1006, 11, 71, 
	3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 7, 72, 1013, 10, 72, 12, 72, 14, 72, 
	1016, 11, 72, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 3, 73, 6, 73, 1024, 10, 
	73, 13, 73, 14, 73, 1025, 3, 73, 3, 73, 5, 73, 1030, 10, 73, 7, 73, 1032, 
	10, 73, 12, 73, 14, 73, 1035, 11, 73, 3, 73, 7, 73, 1038, 10, 73, 12, 73, 
	14, 73, 1041, 11, 73, 3, 73, 5, 73, 1044, 10, 73, 3, 73, 7, 73, 1047, 10, 
	73, 12, 73, 14, 73, 1050, 11, 73, 3, 73, 3, 73, 3, 74, 3, 74, 3, 74, 5, 
	74, 1057, 10, 74, 3, 75, 3, 75, 3, 75, 6, 75, 1062, 10, 75, 13, 75, 14, 
	75, 1063, 3, 75, 3, 75, 5, 75, 1068, 10, 75, 7, 75, 1070, 10, 75, 12, 75, 
	14, 75, 1073, 11, 75, 3, 75, 7, 75, 1076, 10, 75, 12, 75, 14, 75, 1079, 
	11, 75, 3, 75, 3, 75, 3, 75, 3, 76, 3, 76, 7, 76, 1086, 10, 76, 12, 76, 
	14, 76, 1089, 11, 76, 3, 76, 3, 76, 3, 76, 3, 76, 7, 76, 1095, 10, 76, 
	12, 76, 14, 76, 1098, 11, 76, 3, 76, 3, 76, 3, 77, 3, 77, 6, 77, 1104, 
	10, 77, 13, 77, 14, 77, 1105, 3, 77, 3, 77, 3, 77, 15, 239, 437, 683, 706, 
	764, 863, 874, 886, 903, 914, 963, 1014, 1087, 2, 78, 2, 4, 6, 8, 10, 12, 
	14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 
	50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 
	86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 
	118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 
	148, 150, 152, 2, 18, 3, 2, 3, 4, 4, 2, 42, 42, 44, 44, 3, 2, 44, 44, 4, 
	2, 12, 12, 44, 44, 6, 2, 3, 4, 8, 8, 44, 44, 48, 48, 4, 2, 14, 14, 44, 
	44, 4, 2, 13, 13, 44, 44, 4, 2, 10, 10, 44, 44, 4, 2, 5, 6, 26, 26, 5, 
	2, 3, 4, 10, 10, 44, 44, 4, 2, 3, 4, 44, 44, 6, 2, 29, 29, 34, 34, 45, 
	45, 47, 47, 4, 2, 29, 37, 45, 47, 8, 2, 5, 12, 18, 18, 21, 21, 24, 28, 
	41, 41, 48, 48, 4, 2, 29, 37, 45, 46, 4, 2, 8, 8, 43, 43, 2, 1247, 2, 155, 
	3, 2, 2, 2, 4, 171, 3, 2, 2, 2, 6, 190, 3, 2, 2, 2, 8, 199, 3, 2, 2, 2, 
	10, 210, 3, 2, 2, 2, 12, 214, 3, 2, 2, 2, 14, 218, 3, 2, 2, 2, 16, 227, 
	3, 2, 2, 2, 18, 234, 3, 2, 2, 2, 20, 265, 3, 2, 2, 2, 22, 271, 3, 2, 2, 
	2, 24, 279, 3, 2, 2, 2, 26, 299, 3, 2, 2, 2, 28, 311, 3, 2, 2, 2, 30, 315, 
	3, 2, 2, 2, 32, 377, 3, 2, 2, 2, 34, 380, 3, 2, 2, 2, 36, 384, 3, 2, 2, 
	2, 38, 424, 3, 2, 2, 2, 40, 429, 3, 2, 2, 2, 42, 446, 3, 2, 2, 2, 44, 451, 
	3, 2, 2, 2, 46, 453, 3, 2, 2, 2, 48, 462, 3, 2, 2, 2, 50, 471, 3, 2, 2, 
	2, 52, 482, 3, 2, 2, 2, 54, 488, 3, 2, 2, 2, 56, 495, 3, 2, 2, 2, 58, 551, 
	3, 2, 2, 2, 60, 601, 3, 2, 2, 2, 62, 606, 3, 2, 2, 2, 64, 610, 3, 2, 2, 
	2, 66, 660, 3, 2, 2, 2, 68, 672, 3, 2, 2, 2, 70, 676, 3, 2, 2, 2, 72, 678, 
	3, 2, 2, 2, 74, 687, 3, 2, 2, 2, 76, 698, 3, 2, 2, 2, 78, 700, 3, 2, 2, 
	2, 80, 711, 3, 2, 2, 2, 82, 722, 3, 2, 2, 2, 84, 725, 3, 2, 2, 2, 86, 730, 
	3, 2, 2, 2, 88, 742, 3, 2, 2, 2, 90, 751, 3, 2, 2, 2, 92, 755, 3, 2, 2, 
	2, 94, 760, 3, 2, 2, 2, 96, 768, 3, 2, 2, 2, 98, 789, 3, 2, 2, 2, 100, 
	795, 3, 2, 2, 2, 102, 797, 3, 2, 2, 2, 104, 806, 3, 2, 2, 2, 106, 816, 
	3, 2, 2, 2, 108, 824, 3, 2, 2, 2, 110, 835, 3, 2, 2, 2, 112, 840, 3, 2, 
	2, 2, 114, 845, 3, 2, 2, 2, 116, 849, 3, 2, 2, 2, 118, 855, 3, 2, 2, 2, 
	120, 857, 3, 2, 2, 2, 122, 867, 3, 2, 2, 2, 124, 879, 3, 2, 2, 2, 126, 
	893, 3, 2, 2, 2, 128, 897, 3, 2, 2, 2, 130, 908, 3, 2, 2, 2, 132, 919, 
	3, 2, 2, 2, 134, 945, 3, 2, 2, 2, 136, 958, 3, 2, 2, 2, 138, 968, 3, 2, 
	2, 2, 140, 995, 3, 2, 2, 2, 142, 1009, 3, 2, 2, 2, 144, 1019, 3, 2, 2, 
	2, 146, 1056, 3, 2, 2, 2, 148, 1058, 3, 2, 2, 2, 150, 1083, 3, 2, 2, 2, 
	152, 1101, 3, 2, 2, 2, 154, 156, 5, 4, 3, 2, 155, 154, 3, 2, 2, 2, 156, 
	157, 3, 2, 2, 2, 157, 155, 3, 2, 2, 2, 157, 158, 3, 2, 2, 2, 158, 162, 
	3, 2, 2, 2, 159, 161, 7, 43, 2, 2, 160, 159, 3, 2, 2, 2, 161, 164, 3, 2, 
	2, 2, 162, 160, 3, 2, 2, 2, 162, 163, 3, 2, 2, 2, 163, 166, 3, 2, 2, 2, 
	164, 162, 3, 2, 2, 2, 165, 167, 7, 2, 2, 3, 166, 165, 3, 2, 2, 2, 166, 
	167, 3, 2, 2, 2, 167, 3, 3, 2, 2, 2, 168, 170, 7, 43, 2, 2, 169, 168, 3, 
	2, 2, 2, 170, 173, 3, 2, 2, 2, 171, 169, 3, 2, 2, 2, 171, 172, 3, 2, 2, 
	2, 172, 188, 3, 2, 2, 2, 173, 171, 3, 2, 2, 2, 174, 189, 5, 6, 4, 2, 175, 
	189, 5, 8, 5, 2, 176, 189, 5, 150, 76, 2, 177, 189, 5, 10, 6, 2, 178, 189, 
	5, 32, 17, 2, 179, 189, 5, 24, 13, 2, 180, 189, 5, 34, 18, 2, 181, 182, 
	6, 3, 2, 2, 182, 189, 5, 52, 27, 2, 183, 184, 6, 3, 3, 2, 184, 189, 5, 
	54, 28, 2, 185, 186, 6, 3, 4, 2, 186, 189, 5, 28, 15, 2, 187, 189, 5, 64, 
	33, 2, 188, 174, 3, 2, 2, 2, 188, 175, 3, 2, 2, 2, 188, 176, 3, 2, 2, 2, 
	188, 177, 3, 2, 2, 2, 188, 178, 3, 2, 2, 2, 188, 179, 3, 2, 2, 2, 188, 
	180, 3, 2, 2, 2, 188, 181, 3, 2, 2, 2, 188, 183, 3, 2, 2, 2, 188, 185, 
	3, 2, 2, 2, 188, 187, 3, 2, 2, 2, 189, 5, 3, 2, 2, 2, 190, 194, 5, 146, 
	74, 2, 191, 193, 9, 2, 2, 2, 192, 191, 3, 2, 2, 2, 193, 196, 3, 2, 2, 2, 
	194, 192, 3, 2, 2, 2, 194, 195, 3, 2, 2, 2, 195, 197, 3, 2, 2, 2, 196, 
	194, 3, 2, 2, 2, 197, 198, 9, 3, 2, 2, 198, 7, 3, 2, 2, 2, 199, 203, 5, 
	148, 75, 2, 200, 202, 9, 2, 2, 2, 201, 200, 3, 2, 2, 2, 202, 205, 3, 2, 
	2, 2, 203, 201, 3, 2, 2, 2, 203, 204, 3, 2, 2, 2, 204, 206, 3, 2, 2, 2, 
	205, 203, 3, 2, 2, 2, 206, 207, 9, 3, 2, 2, 207, 9, 3, 2, 2, 2, 208, 211, 
	5, 12, 7, 2, 209, 211, 5, 18, 10, 2, 210, 208, 3, 2, 2, 2, 210, 209, 3, 
	2, 2, 2, 211, 11, 3, 2, 2, 2, 212, 215, 5, 14, 8, 2, 213, 215, 5, 16, 9, 
	2, 214, 212, 3, 2, 2, 2, 214, 213, 3, 2, 2, 2, 215, 13, 3, 2, 2, 2, 216, 
	217, 6, 8, 5, 2, 217, 219, 5, 66, 34, 2, 218, 216, 3, 2, 2, 2, 219, 220, 
	3, 2, 2, 2, 220, 218, 3, 2, 2, 2, 220, 221, 3, 2, 2, 2, 221, 222, 3, 2, 
	2, 2, 222, 223, 7, 44, 2, 2, 223, 224, 7, 38, 2, 2, 224, 15, 3, 2, 2, 2, 
	225, 226, 6, 9, 6, 2, 226, 228, 5, 66, 34, 2, 227, 225, 3, 2, 2, 2, 228, 
	229, 3, 2, 2, 2, 229, 227, 3, 2, 2, 2, 229, 230, 3, 2, 2, 2, 230, 231, 
	3, 2, 2, 2, 231, 232, 7, 44, 2, 2, 232, 233, 7, 39, 2, 2, 233, 17, 3, 2, 
	2, 2, 234, 235, 7, 40, 2, 2, 235, 237, 9, 2, 2, 2, 236, 238, 5, 66, 34, 
	2, 237, 236, 3, 2, 2, 2, 238, 239, 3, 2, 2, 2, 239, 240, 3, 2, 2, 2, 239, 
	237, 3, 2, 2, 2, 240, 247, 3, 2, 2, 2, 241, 243, 9, 2, 2, 2, 242, 241, 
	3, 2, 2, 2, 243, 246, 3, 2, 2, 2, 244, 242, 3, 2, 2, 2, 244, 245, 3, 2, 
	2, 2, 245, 248, 3, 2, 2, 2, 246, 244, 3, 2, 2, 2, 247, 244, 3, 2, 2, 2, 
	247, 248, 3, 2, 2, 2, 248, 255, 3, 2, 2, 2, 249, 251, 7, 41, 2, 2, 250, 
	249, 3, 2, 2, 2, 251, 254, 3, 2, 2, 2, 252, 250, 3, 2, 2, 2, 252, 253, 
	3, 2, 2, 2, 253, 256, 3, 2, 2, 2, 254, 252, 3, 2, 2, 2, 255, 252, 3, 2, 
	2, 2, 255, 256, 3, 2, 2, 2, 256, 258, 3, 2, 2, 2, 257, 259, 9, 2, 2, 2, 
	258, 257, 3, 2, 2, 2, 258, 259, 3, 2, 2, 2, 259, 260, 3, 2, 2, 2, 260, 
	261, 9, 3, 2, 2, 261, 19, 3, 2, 2, 2, 262, 264, 10, 4, 2, 2, 263, 262, 
	3, 2, 2, 2, 264, 267, 3, 2, 2, 2, 265, 263, 3, 2, 2, 2, 265, 266, 3, 2, 
	2, 2, 266, 268, 3, 2, 2, 2, 267, 265, 3, 2, 2, 2, 268, 269, 7, 44, 2, 2, 
	269, 21, 3, 2, 2, 2, 270, 272, 7, 3, 2, 2, 271, 270, 3, 2, 2, 2, 271, 272, 
	3, 2, 2, 2, 272, 274, 3, 2, 2, 2, 273, 275, 7, 3, 2, 2, 274, 273, 3, 2, 
	2, 2, 274, 275, 3, 2, 2, 2, 275, 277, 3, 2, 2, 2, 276, 278, 7, 3, 2, 2, 
	277, 276, 3, 2, 2, 2, 277, 278, 3, 2, 2, 2, 278, 23, 3, 2, 2, 2, 279, 294, 
	6, 13, 7, 3, 280, 282, 5, 26, 14, 2, 281, 280, 3, 2, 2, 2, 281, 282, 3, 
	2, 2, 2, 282, 286, 3, 2, 2, 2, 283, 285, 9, 2, 2, 2, 284, 283, 3, 2, 2, 
	2, 285, 288, 3, 2, 2, 2, 286, 284, 3, 2, 2, 2, 286, 287, 3, 2, 2, 2, 287, 
	289, 3, 2, 2, 2, 288, 286, 3, 2, 2, 2, 289, 291, 7, 8, 2, 2, 290, 292, 
	9, 2, 2, 2, 291, 290, 3, 2, 2, 2, 291, 292, 3, 2, 2, 2, 292, 293, 3, 2, 
	2, 2, 293, 295, 5, 20, 11, 2, 294, 281, 3, 2, 2, 2, 295, 296, 3, 2, 2, 
	2, 296, 294, 3, 2, 2, 2, 296, 297, 3, 2, 2, 2, 297, 25, 3, 2, 2, 2, 298, 
	300, 7, 43, 2, 2, 299, 298, 3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 299, 
	3, 2, 2, 2, 301, 302, 3, 2, 2, 2, 302, 27, 3, 2, 2, 2, 303, 307, 6, 15, 
	8, 3, 304, 306, 5, 30, 16, 2, 305, 304, 3, 2, 2, 2, 306, 309, 3, 2, 2, 
	2, 307, 305, 3, 2, 2, 2, 307, 308, 3, 2, 2, 2, 308, 310, 3, 2, 2, 2, 309, 
	307, 3, 2, 2, 2, 310, 312, 5, 20, 11, 2, 311, 303, 3, 2, 2, 2, 312, 313, 
	3, 2, 2, 2, 313, 311, 3, 2, 2, 2, 313, 314, 3, 2, 2, 2, 314, 29, 3, 2, 
	2, 2, 315, 316, 7, 43, 2, 2, 316, 31, 3, 2, 2, 2, 317, 372, 5, 22, 12, 
	2, 318, 320, 7, 5, 2, 2, 319, 321, 9, 2, 2, 2, 320, 319, 3, 2, 2, 2, 320, 
	321, 3, 2, 2, 2, 321, 322, 3, 2, 2, 2, 322, 324, 7, 5, 2, 2, 323, 325, 
	9, 2, 2, 2, 324, 323, 3, 2, 2, 2, 324, 325, 3, 2, 2, 2, 325, 326, 3, 2, 
	2, 2, 326, 333, 7, 5, 2, 2, 327, 329, 9, 2, 2, 2, 328, 327, 3, 2, 2, 2, 
	328, 329, 3, 2, 2, 2, 329, 330, 3, 2, 2, 2, 330, 332, 7, 5, 2, 2, 331, 
	328, 3, 2, 2, 2, 332, 335, 3, 2, 2, 2, 333, 331, 3, 2, 2, 2, 333, 334, 
	3, 2, 2, 2, 334, 373, 3, 2, 2, 2, 335, 333, 3, 2, 2, 2, 336, 338, 7, 6, 
	2, 2, 337, 339, 9, 2, 2, 2, 338, 337, 3, 2, 2, 2, 338, 339, 3, 2, 2, 2, 
	339, 340, 3, 2, 2, 2, 340, 342, 7, 6, 2, 2, 341, 343, 9, 2, 2, 2, 342, 
	341, 3, 2, 2, 2, 342, 343, 3, 2, 2, 2, 343, 344, 3, 2, 2, 2, 344, 351, 
	7, 6, 2, 2, 345, 347, 9, 2, 2, 2, 346, 345, 3, 2, 2, 2, 346, 347, 3, 2, 
	2, 2, 347, 348, 3, 2, 2, 2, 348, 350, 7, 6, 2, 2, 349, 346, 3, 2, 2, 2, 
	350, 353, 3, 2, 2, 2, 351, 349, 3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352, 
	373, 3, 2, 2, 2, 353, 351, 3, 2, 2, 2, 354, 356, 7, 7, 2, 2, 355, 357, 
	9, 2, 2, 2, 356, 355, 3, 2, 2, 2, 356, 357, 3, 2, 2, 2, 357, 358, 3, 2, 
	2, 2, 358, 360, 7, 7, 2, 2, 359, 361, 9, 2, 2, 2, 360, 359, 3, 2, 2, 2, 
	360, 361, 3, 2, 2, 2, 361, 362, 3, 2, 2, 2, 362, 369, 7, 7, 2, 2, 363, 
	365, 9, 2, 2, 2, 364, 363, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 366, 
	3, 2, 2, 2, 366, 368, 7, 7, 2, 2, 367, 364, 3, 2, 2, 2, 368, 371, 3, 2, 
	2, 2, 369, 367, 3, 2, 2, 2, 369, 370, 3, 2, 2, 2, 370, 373, 3, 2, 2, 2, 
	371, 369, 3, 2, 2, 2, 372, 318, 3, 2, 2, 2, 372, 336, 3, 2, 2, 2, 372, 
	354, 3, 2, 2, 2, 373, 374, 3, 2, 2, 2, 374, 375, 7, 44, 2, 2, 375, 378, 
	3, 2, 2, 2, 376, 378, 7, 39, 2, 2, 377, 317, 3, 2, 2, 2, 377, 376, 3, 2, 
	2, 2, 378, 33, 3, 2, 2, 2, 379, 381, 5, 36, 19, 2, 380, 379, 3, 2, 2, 2, 
	381, 382, 3, 2, 2, 2, 382, 380, 3, 2, 2, 2, 382, 383, 3, 2, 2, 2, 383, 
	35, 3, 2, 2, 2, 384, 385, 5, 22, 12, 2, 385, 386, 5, 38, 20, 2, 386, 388, 
	7, 15, 2, 2, 387, 389, 9, 2, 2, 2, 388, 387, 3, 2, 2, 2, 389, 390, 3, 2, 
	2, 2, 390, 388, 3, 2, 2, 2, 390, 391, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 
	392, 414, 5, 42, 22, 2, 393, 395, 9, 2, 2, 2, 394, 393, 3, 2, 2, 2, 395, 
	396, 3, 2, 2, 2, 396, 394, 3, 2, 2, 2, 396, 397, 3, 2, 2, 2, 397, 412, 
	3, 2, 2, 2, 398, 400, 9, 2, 2, 2, 399, 398, 3, 2, 2, 2, 400, 403, 3, 2, 
	2, 2, 401, 399, 3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402, 404, 3, 2, 2, 2, 
	403, 401, 3, 2, 2, 2, 404, 408, 7, 44, 2, 2, 405, 407, 9, 2, 2, 2, 406, 
	405, 3, 2, 2, 2, 407, 410, 3, 2, 2, 2, 408, 406, 3, 2, 2, 2, 408, 409, 
	3, 2, 2, 2, 409, 412, 3, 2, 2, 2, 410, 408, 3, 2, 2, 2, 411, 394, 3, 2, 
	2, 2, 411, 401, 3, 2, 2, 2, 412, 413, 3, 2, 2, 2, 413, 415, 5, 44, 23, 
	2, 414, 411, 3, 2, 2, 2, 414, 415, 3, 2, 2, 2, 415, 419, 3, 2, 2, 2, 416, 
	418, 9, 2, 2, 2, 417, 416, 3, 2, 2, 2, 418, 421, 3, 2, 2, 2, 419, 417, 
	3, 2, 2, 2, 419, 420, 3, 2, 2, 2, 420, 422, 3, 2, 2, 2, 421, 419, 3, 2, 
	2, 2, 422, 423, 7, 44, 2, 2, 423, 37, 3, 2, 2, 2, 424, 425, 7, 11, 2, 2, 
	425, 426, 5, 40, 21, 2, 426, 427, 7, 12, 2, 2, 427, 39, 3, 2, 2, 2, 428, 
	430, 10, 5, 2, 2, 429, 428, 3, 2, 2, 2, 430, 431, 3, 2, 2, 2, 431, 429, 
	3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432, 41, 3, 2, 2, 2, 433, 437, 7, 48, 
	2, 2, 434, 436, 11, 2, 2, 2, 435, 434, 3, 2, 2, 2, 436, 439, 3, 2, 2, 2, 
	437, 438, 3, 2, 2, 2, 437, 435, 3, 2, 2, 2, 438, 440, 3, 2, 2, 2, 439, 
	437, 3, 2, 2, 2, 440, 447, 7, 8, 2, 2, 441, 443, 10, 6, 2, 2, 442, 441, 
	3, 2, 2, 2, 443, 444, 3, 2, 2, 2, 444, 442, 3, 2, 2, 2, 444, 445, 3, 2, 
	2, 2, 445, 447, 3, 2, 2, 2, 446, 433, 3, 2, 2, 2, 446, 442, 3, 2, 2, 2, 
	447, 43, 3, 2, 2, 2, 448, 452, 5, 46, 24, 2, 449, 452, 5, 48, 25, 2, 450, 
	452, 5, 50, 26, 2, 451, 448, 3, 2, 2, 2, 451, 449, 3, 2, 2, 2, 451, 450, 
	3, 2, 2, 2, 452, 45, 3, 2, 2, 2, 453, 457, 7, 14, 2, 2, 454, 456, 10, 7, 
	2, 2, 455, 454, 3, 2, 2, 2, 456, 459, 3, 2, 2, 2, 457, 455, 3, 2, 2, 2, 
	457, 458, 3, 2, 2, 2, 458, 460, 3, 2, 2, 2, 459, 457, 3, 2, 2, 2, 460, 
	461, 7, 14, 2, 2, 461, 47, 3, 2, 2, 2, 462, 466, 7, 13, 2, 2, 463, 465, 
	10, 8, 2, 2, 464, 463, 3, 2, 2, 2, 465, 468, 3, 2, 2, 2, 466, 464, 3, 2, 
	2, 2, 466, 467, 3, 2, 2, 2, 467, 469, 3, 2, 2, 2, 468, 466, 3, 2, 2, 2, 
	469, 470, 7, 13, 2, 2, 470, 49, 3, 2, 2, 2, 471, 475, 7, 9, 2, 2, 472, 
	474, 10, 9, 2, 2, 473, 472, 3, 2, 2, 2, 474, 477, 3, 2, 2, 2, 475, 473, 
	3, 2, 2, 2, 475, 476, 3, 2, 2, 2, 476, 478, 3, 2, 2, 2, 477, 475, 3, 2, 
	2, 2, 478, 479, 7, 10, 2, 2, 479, 51, 3, 2, 2, 2, 480, 481, 6, 27, 9, 3, 
	481, 483, 5, 56, 29, 2, 482, 480, 3, 2, 2, 2, 483, 484, 3, 2, 2, 2, 484, 
	482, 3, 2, 2, 2, 484, 485, 3, 2, 2, 2, 485, 53, 3, 2, 2, 2, 486, 487, 6, 
	28, 10, 3, 487, 489, 5, 58, 30, 2, 488, 486, 3, 2, 2, 2, 489, 490, 3, 2, 
	2, 2, 490, 488, 3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491, 55, 3, 2, 2, 2, 
	492, 494, 7, 43, 2, 2, 493, 492, 3, 2, 2, 2, 494, 497, 3, 2, 2, 2, 495, 
	493, 3, 2, 2, 2, 495, 496, 3, 2, 2, 2, 496, 501, 3, 2, 2, 2, 497, 495, 
	3, 2, 2, 2, 498, 500, 9, 2, 2, 2, 499, 498, 3, 2, 2, 2, 500, 503, 3, 2, 
	2, 2, 501, 499, 3, 2, 2, 2, 501, 502, 3, 2, 2, 2, 502, 505, 3, 2, 2, 2, 
	503, 501, 3, 2, 2, 2, 504, 506, 7, 47, 2, 2, 505, 504, 3, 2, 2, 2, 506, 
	507, 3, 2, 2, 2, 507, 505, 3, 2, 2, 2, 507, 508, 3, 2, 2, 2, 508, 509, 
	3, 2, 2, 2, 509, 511, 7, 21, 2, 2, 510, 512, 9, 2, 2, 2, 511, 510, 3, 2, 
	2, 2, 512, 513, 3, 2, 2, 2, 513, 511, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 
	514, 515, 3, 2, 2, 2, 515, 546, 5, 60, 31, 2, 516, 519, 6, 29, 11, 3, 517, 
	520, 5, 52, 27, 2, 518, 520, 5, 54, 28, 2, 519, 517, 3, 2, 2, 2, 519, 518, 
	3, 2, 2, 2, 520, 547, 3, 2, 2, 2, 521, 522, 6, 29, 12, 3, 522, 540, 5, 
	62, 32, 2, 523, 524, 6, 29, 13, 3, 524, 541, 5, 28, 15, 2, 525, 528, 6, 
	29, 14, 3, 526, 529, 5, 52, 27, 2, 527, 529, 5, 54, 28, 2, 528, 526, 3, 
	2, 2, 2, 528, 527, 3, 2, 2, 2, 529, 541, 3, 2, 2, 2, 530, 531, 6, 29, 15, 
	3, 531, 541, 5, 24, 13, 2, 532, 536, 6, 29, 16, 3, 533, 535, 9, 2, 2, 2, 
	534, 533, 3, 2, 2, 2, 535, 538, 3, 2, 2, 2, 536, 534, 3, 2, 2, 2, 536, 
	537, 3, 2, 2, 2, 537, 539, 3, 2, 2, 2, 538, 536, 3, 2, 2, 2, 539, 541, 
	5, 60, 31, 2, 540, 523, 3, 2, 2, 2, 540, 525, 3, 2, 2, 2, 540, 530, 3, 
	2, 2, 2, 540, 532, 3, 2, 2, 2, 541, 543, 3, 2, 2, 2, 542, 521, 3, 2, 2, 
	2, 543, 544, 3, 2, 2, 2, 544, 542, 3, 2, 2, 2, 544, 545, 3, 2, 2, 2, 545, 
	547, 3, 2, 2, 2, 546, 516, 3, 2, 2, 2, 546, 542, 3, 2, 2, 2, 546, 547, 
	3, 2, 2, 2, 547, 57, 3, 2, 2, 2, 548, 550, 7, 43, 2, 2, 549, 548, 3, 2, 
	2, 2, 550, 553, 3, 2, 2, 2, 551, 549, 3, 2, 2, 2, 551, 552, 3, 2, 2, 2, 
	552, 557, 3, 2, 2, 2, 553, 551, 3, 2, 2, 2, 554, 556, 9, 2, 2, 2, 555, 
	554, 3, 2, 2, 2, 556, 559, 3, 2, 2, 2, 557, 555, 3, 2, 2, 2, 557, 558, 
	3, 2, 2, 2, 558, 560, 3, 2, 2, 2, 559, 557, 3, 2, 2, 2, 560, 562, 9, 10, 
	2, 2, 561, 563, 9, 2, 2, 2, 562, 561, 3, 2, 2, 2, 563, 564, 3, 2, 2, 2, 
	564, 562, 3, 2, 2, 2, 564, 565, 3, 2, 2, 2, 565, 566, 3, 2, 2, 2, 566, 
	597, 5, 60, 31, 2, 567, 570, 6, 30, 17, 3, 568, 571, 5, 52, 27, 2, 569, 
	571, 5, 54, 28, 2, 570, 568, 3, 2, 2, 2, 570, 569, 3, 2, 2, 2, 571, 598, 
	3, 2, 2, 2, 572, 573, 6, 30, 18, 3, 573, 591, 5, 62, 32, 2, 574, 575, 6, 
	30, 19, 3, 575, 592, 5, 28, 15, 2, 576, 579, 6, 30, 20, 3, 577, 580, 5, 
	52, 27, 2, 578, 580, 5, 54, 28, 2, 579, 577, 3, 2, 2, 2, 579, 578, 3, 2, 
	2, 2, 580, 592, 3, 2, 2, 2, 581, 582, 6, 30, 21, 3, 582, 592, 5, 24, 13, 
	2, 583, 587, 6, 30, 22, 3, 584, 586, 9, 2, 2, 2, 585, 584, 3, 2, 2, 2, 
	586, 589, 3, 2, 2, 2, 587, 585, 3, 2, 2, 2, 587, 588, 3, 2, 2, 2, 588, 
	590, 3, 2, 2, 2, 589, 587, 3, 2, 2, 2, 590, 592, 5, 60, 31, 2, 591, 574, 
	3, 2, 2, 2, 591, 576, 3, 2, 2, 2, 591, 581, 3, 2, 2, 2, 591, 583, 3, 2, 
	2, 2, 592, 594, 3, 2, 2, 2, 593, 572, 3, 2, 2, 2, 594, 595, 3, 2, 2, 2, 
	595, 593, 3, 2, 2, 2, 595, 596, 3, 2, 2, 2, 596, 598, 3, 2, 2, 2, 597, 
	567, 3, 2, 2, 2, 597, 593, 3, 2, 2, 2, 597, 598, 3, 2, 2, 2, 598, 59, 3, 
	2, 2, 2, 599, 600, 6, 31, 23, 3, 600, 602, 5, 66, 34, 2, 601, 599, 3, 2, 
	2, 2, 602, 603, 3, 2, 2, 2, 603, 601, 3, 2, 2, 2, 603, 604, 3, 2, 2, 2, 
	604, 61, 3, 2, 2, 2, 605, 607, 7, 43, 2, 2, 606, 605, 3, 2, 2, 2, 607, 
	608, 3, 2, 2, 2, 608, 606, 3, 2, 2, 2, 608, 609, 3, 2, 2, 2, 609, 63, 3, 
	2, 2, 2, 610, 612, 5, 22, 12, 2, 611, 613, 5, 66, 34, 2, 612, 611, 3, 2, 
	2, 2, 613, 614, 3, 2, 2, 2, 614, 612, 3, 2, 2, 2, 614, 615, 3, 2, 2, 2, 
	615, 616, 3, 2, 2, 2, 616, 617, 7, 44, 2, 2, 617, 65, 3, 2, 2, 2, 618, 
	661, 5, 68, 35, 2, 619, 661, 7, 45, 2, 2, 620, 661, 7, 46, 2, 2, 621, 661, 
	7, 47, 2, 2, 622, 661, 7, 44, 2, 2, 623, 661, 7, 42, 2, 2, 624, 661, 7, 
	3, 2, 2, 625, 661, 7, 4, 2, 2, 626, 661, 7, 49, 2, 2, 627, 661, 7, 5, 2, 
	2, 628, 661, 7, 7, 2, 2, 629, 661, 7, 15, 2, 2, 630, 661, 7, 16, 2, 2, 
	631, 661, 7, 20, 2, 2, 632, 661, 7, 21, 2, 2, 633, 661, 7, 48, 2, 2, 634, 
	661, 7, 8, 2, 2, 635, 661, 7, 9, 2, 2, 636, 661, 7, 10, 2, 2, 637, 661, 
	7, 18, 2, 2, 638, 661, 7, 41, 2, 2, 639, 661, 7, 11, 2, 2, 640, 661, 7, 
	12, 2, 2, 641, 661, 7, 23, 2, 2, 642, 661, 7, 24, 2, 2, 643, 661, 7, 14, 
	2, 2, 644, 661, 7, 13, 2, 2, 645, 661, 7, 25, 2, 2, 646, 661, 7, 26, 2, 
	2, 647, 661, 7, 6, 2, 2, 648, 661, 7, 27, 2, 2, 649, 661, 7, 28, 2, 2, 
	650, 661, 7, 29, 2, 2, 651, 661, 7, 30, 2, 2, 652, 661, 7, 31, 2, 2, 653, 
	661, 7, 32, 2, 2, 654, 661, 7, 33, 2, 2, 655, 661, 7, 34, 2, 2, 656, 661, 
	7, 35, 2, 2, 657, 661, 7, 36, 2, 2, 658, 661, 7, 37, 2, 2, 659, 661, 7, 
	17, 2, 2, 660, 618, 3, 2, 2, 2, 660, 619, 3, 2, 2, 2, 660, 620, 3, 2, 2, 
	2, 660, 621, 3, 2, 2, 2, 660, 622, 3, 2, 2, 2, 660, 623, 3, 2, 2, 2, 660, 
	624, 3, 2, 2, 2, 660, 625, 3, 2, 2, 2, 660, 626, 3, 2, 2, 2, 660, 627, 
	3, 2, 2, 2, 660, 628, 3, 2, 2, 2, 660, 629, 3, 2, 2, 2, 660, 630, 3, 2, 
	2, 2, 660, 631, 3, 2, 2, 2, 660, 632, 3, 2, 2, 2, 660, 633, 3, 2, 2, 2, 
	660, 634, 3, 2, 2, 2, 660, 635, 3, 2, 2, 2, 660, 636, 3, 2, 2, 2, 660, 
	637, 3, 2, 2, 2, 660, 638, 3, 2, 2, 2, 660, 639, 3, 2, 2, 2, 660, 640, 
	3, 2, 2, 2, 660, 641, 3, 2, 2, 2, 660, 642, 3, 2, 2, 2, 660, 643, 3, 2, 
	2, 2, 660, 644, 3, 2, 2, 2, 660, 645, 3, 2, 2, 2, 660, 646, 3, 2, 2, 2, 
	660, 647, 3, 2, 2, 2, 660, 648, 3, 2, 2, 2, 660, 649, 3, 2, 2, 2, 660, 
	650, 3, 2, 2, 2, 660, 651, 3, 2, 2, 2, 660, 652, 3, 2, 2, 2, 660, 653, 
	3, 2, 2, 2, 660, 654, 3, 2, 2, 2, 660, 655, 3, 2, 2, 2, 660, 656, 3, 2, 
	2, 2, 660, 657, 3, 2, 2, 2, 660, 658, 3, 2, 2, 2, 660, 659, 3, 2, 2, 2, 
	661, 67, 3, 2, 2, 2, 662, 673, 5, 76, 39, 2, 663, 673, 5, 70, 36, 2, 664, 
	673, 5, 82, 42, 2, 665, 673, 5, 92, 47, 2, 666, 673, 5, 118, 60, 2, 667, 
	673, 5, 146, 74, 2, 668, 673, 5, 148, 75, 2, 669, 673, 5, 152, 77, 2, 670, 
	673, 5, 108, 55, 2, 671, 673, 5, 116, 59, 2, 672, 662, 3, 2, 2, 2, 672, 
	663, 3, 2, 2, 2, 672, 664, 3, 2, 2, 2, 672, 665, 3, 2, 2, 2, 672, 666, 
	3, 2, 2, 2, 672, 667, 3, 2, 2, 2, 672, 668, 3, 2, 2, 2, 672, 669, 3, 2, 
	2, 2, 672, 670, 3, 2, 2, 2, 672, 671, 3, 2, 2, 2, 673, 69, 3, 2, 2, 2, 
	674, 677, 5, 72, 37, 2, 675, 677, 5, 74, 38, 2, 676, 674, 3, 2, 2, 2, 676, 
	675, 3, 2, 2, 2, 677, 71, 3, 2, 2, 2, 678, 679, 6, 37, 24, 2, 679, 681, 
	7, 5, 2, 2, 680, 682, 5, 66, 34, 2, 681, 680, 3, 2, 2, 2, 682, 683, 3, 
	2, 2, 2, 683, 684, 3, 2, 2, 2, 683, 681, 3, 2, 2, 2, 684, 685, 3, 2, 2, 
	2, 685, 686, 7, 5, 2, 2, 686, 73, 3, 2, 2, 2, 687, 688, 6, 38, 25, 2, 688, 
	690, 7, 7, 2, 2, 689, 691, 5, 66, 34, 2, 690, 689, 3, 2, 2, 2, 691, 692, 
	3, 2, 2, 2, 692, 690, 3, 2, 2, 2, 692, 693, 3, 2, 2, 2, 693, 694, 3, 2, 
	2, 2, 694, 695, 7, 7, 2, 2, 695, 75, 3, 2, 2, 2, 696, 699, 5, 78, 40, 2, 
	697, 699, 5, 80, 41, 2, 698, 696, 3, 2, 2, 2, 698, 697, 3, 2, 2, 2, 699, 
	77, 3, 2, 2, 2, 700, 701, 6, 40, 26, 2, 701, 702, 7, 5, 2, 2, 702, 704, 
	7, 5, 2, 2, 703, 705, 5, 66, 34, 2, 704, 703, 3, 2, 2, 2, 705, 706, 3, 
	2, 2, 2, 706, 707, 3, 2, 2, 2, 706, 704, 3, 2, 2, 2, 707, 708, 3, 2, 2, 
	2, 708, 709, 7, 5, 2, 2, 709, 710, 7, 5, 2, 2, 710, 79, 3, 2, 2, 2, 711, 
	712, 6, 41, 27, 2, 712, 713, 7, 7, 2, 2, 713, 715, 7, 7, 2, 2, 714, 716, 
	5, 66, 34, 2, 715, 714, 3, 2, 2, 2, 716, 717, 3, 2, 2, 2, 717, 715, 3, 
	2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 719, 3, 2, 2, 2, 719, 720, 7, 7, 2, 
	2, 720, 721, 7, 7, 2, 2, 721, 81, 3, 2, 2, 2, 722, 723, 7, 18, 2, 2, 723, 
	724, 5, 84, 43, 2, 724, 83, 3, 2, 2, 2, 725, 728, 5, 88, 45, 2, 726, 729, 
	5, 86, 44, 2, 727, 729, 5, 90, 46, 2, 728, 726, 3, 2, 2, 2, 728, 727, 3, 
	2, 2, 2, 729, 85, 3, 2, 2, 2, 730, 731, 7, 9, 2, 2, 731, 738, 5, 98, 50, 
	2, 732, 734, 9, 2, 2, 2, 733, 732, 3, 2, 2, 2, 734, 735, 3, 2, 2, 2, 735, 
	733, 3, 2, 2, 2, 735, 736, 3, 2, 2, 2, 736, 737, 3, 2, 2, 2, 737, 739, 
	5, 100, 51, 2, 738, 733, 3, 2, 2, 2, 738, 739, 3, 2, 2, 2, 739, 740, 3, 
	2, 2, 2, 740, 741, 7, 10, 2, 2, 741, 87, 3, 2, 2, 2, 742, 746, 7, 11, 2, 
	2, 743, 745, 10, 5, 2, 2, 744, 743, 3, 2, 2, 2, 745, 748, 3, 2, 2, 2, 746, 
	744, 3, 2, 2, 2, 746, 747, 3, 2, 2, 2, 747, 749, 3, 2, 2, 2, 748, 746, 
	3, 2, 2, 2, 749, 750, 7, 12, 2, 2, 750, 89, 3, 2, 2, 2, 751, 752, 7, 11, 
	2, 2, 752, 753, 5, 40, 21, 2, 753, 754, 7, 12, 2, 2, 754, 91, 3, 2, 2, 
	2, 755, 758, 5, 94, 48, 2, 756, 759, 5, 96, 49, 2, 757, 759, 5, 106, 54, 
	2, 758, 756, 3, 2, 2, 2, 758, 757, 3, 2, 2, 2, 758, 759, 3, 2, 2, 2, 759, 
	93, 3, 2, 2, 2, 760, 762, 7, 11, 2, 2, 761, 763, 5, 66, 34, 2, 762, 761, 
	3, 2, 2, 2, 763, 764, 3, 2, 2, 2, 764, 765, 3, 2, 2, 2, 764, 762, 3, 2, 
	2, 2, 765, 766, 3, 2, 2, 2, 766, 767, 7, 12, 2, 2, 767, 95, 3, 2, 2, 2, 
	768, 770, 7, 9, 2, 2, 769, 771, 5, 98, 50, 2, 770, 769, 3, 2, 2, 2, 770, 
	771, 3, 2, 2, 2, 771, 778, 3, 2, 2, 2, 772, 774, 9, 2, 2, 2, 773, 772, 
	3, 2, 2, 2, 774, 775, 3, 2, 2, 2, 775, 773, 3, 2, 2, 2, 775, 776, 3, 2, 
	2, 2, 776, 777, 3, 2, 2, 2, 777, 779, 5, 100, 51, 2, 778, 773, 3, 2, 2, 
	2, 778, 779, 3, 2, 2, 2, 779, 783, 3, 2, 2, 2, 780, 782, 9, 2, 2, 2, 781, 
	780, 3, 2, 2, 2, 782, 785, 3, 2, 2, 2, 783, 781, 3, 2, 2, 2, 783, 784, 
	3, 2, 2, 2, 784, 786, 3, 2, 2, 2, 785, 783, 3, 2, 2, 2, 786, 787, 7, 10, 
	2, 2, 787, 97, 3, 2, 2, 2, 788, 790, 10, 11, 2, 2, 789, 788, 3, 2, 2, 2, 
	790, 791, 3, 2, 2, 2, 791, 789, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 
	99, 3, 2, 2, 2, 793, 796, 5, 102, 52, 2, 794, 796, 5, 104, 53, 2, 795, 
	793, 3, 2, 2, 2, 795, 794, 3, 2, 2, 2, 796, 101, 3, 2, 2, 2, 797, 801, 
	7, 14, 2, 2, 798, 800, 10, 7, 2, 2, 799, 798, 3, 2, 2, 2, 800, 803, 3, 
	2, 2, 2, 801, 799, 3, 2, 2, 2, 801, 802, 3, 2, 2, 2, 802, 804, 3, 2, 2, 
	2, 803, 801, 3, 2, 2, 2, 804, 805, 7, 14, 2, 2, 805, 103, 3, 2, 2, 2, 806, 
	810, 7, 13, 2, 2, 807, 809, 10, 8, 2, 2, 808, 807, 3, 2, 2, 2, 809, 812, 
	3, 2, 2, 2, 810, 808, 3, 2, 2, 2, 810, 811, 3, 2, 2, 2, 811, 813, 3, 2, 
	2, 2, 812, 810, 3, 2, 2, 2, 813, 814, 7, 13, 2, 2, 814, 105, 3, 2, 2, 2, 
	815, 817, 9, 12, 2, 2, 816, 815, 3, 2, 2, 2, 816, 817, 3, 2, 2, 2, 817, 
	818, 3, 2, 2, 2, 818, 820, 7, 11, 2, 2, 819, 821, 5, 40, 21, 2, 820, 819, 
	3, 2, 2, 2, 820, 821, 3, 2, 2, 2, 821, 822, 3, 2, 2, 2, 822, 823, 7, 12, 
	2, 2, 823, 107, 3, 2, 2, 2, 824, 830, 7, 23, 2, 2, 825, 826, 7, 41, 2, 
	2, 826, 831, 5, 110, 56, 2, 827, 828, 7, 41, 2, 2, 828, 831, 5, 112, 57, 
	2, 829, 831, 5, 114, 58, 2, 830, 825, 3, 2, 2, 2, 830, 827, 3, 2, 2, 2, 
	830, 829, 3, 2, 2, 2, 831, 832, 3, 2, 2, 2, 832, 833, 7, 16, 2, 2, 833, 
	109, 3, 2, 2, 2, 834, 836, 9, 13, 2, 2, 835, 834, 3, 2, 2, 2, 836, 837, 
	3, 2, 2, 2, 837, 835, 3, 2, 2, 2, 837, 838, 3, 2, 2, 2, 838, 111, 3, 2, 
	2, 2, 839, 841, 7, 47, 2, 2, 840, 839, 3, 2, 2, 2, 841, 842, 3, 2, 2, 2, 
	842, 840, 3, 2, 2, 2, 842, 843, 3, 2, 2, 2, 843, 113, 3, 2, 2, 2, 844, 
	846, 9, 14, 2, 2, 845, 844, 3, 2, 2, 2, 846, 847, 3, 2, 2, 2, 847, 845, 
	3, 2, 2, 2, 847, 848, 3, 2, 2, 2, 848, 115, 3, 2, 2, 2, 849, 850, 7, 24, 
	2, 2, 850, 851, 9, 15, 2, 2, 851, 117, 3, 2, 2, 2, 852, 856, 5, 124, 63, 
	2, 853, 856, 5, 122, 62, 2, 854, 856, 5, 120, 61, 2, 855, 852, 3, 2, 2, 
	2, 855, 853, 3, 2, 2, 2, 855, 854, 3, 2, 2, 2, 856, 119, 3, 2, 2, 2, 857, 
	858, 6, 61, 28, 2, 858, 861, 7, 25, 2, 2, 859, 860, 6, 61, 29, 2, 860, 
	862, 11, 2, 2, 2, 861, 859, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2, 863, 864, 
	3, 2, 2, 2, 863, 861, 3, 2, 2, 2, 864, 865, 3, 2, 2, 2, 865, 866, 7, 25, 
	2, 2, 866, 121, 3, 2, 2, 2, 867, 868, 6, 62, 30, 2, 868, 869, 7, 25, 2, 
	2, 869, 872, 7, 25, 2, 2, 870, 871, 6, 62, 31, 2, 871, 873, 11, 2, 2, 2, 
	872, 870, 3, 2, 2, 2, 873, 874, 3, 2, 2, 2, 874, 875, 3, 2, 2, 2, 874, 
	872, 3, 2, 2, 2, 875, 876, 3, 2, 2, 2, 876, 877, 7, 25, 2, 2, 877, 878, 
	7, 25, 2, 2, 878, 123, 3, 2, 2, 2, 879, 880, 7, 25, 2, 2, 880, 881, 7, 
	25, 2, 2, 881, 884, 7, 3, 2, 2, 882, 883, 6, 63, 32, 2, 883, 885, 11, 2, 
	2, 2, 884, 882, 3, 2, 2, 2, 885, 886, 3, 2, 2, 2, 886, 887, 3, 2, 2, 2, 
	886, 884, 3, 2, 2, 2, 887, 888, 3, 2, 2, 2, 888, 889, 7, 3, 2, 2, 889, 
	890, 7, 25, 2, 2, 890, 891, 7, 25, 2, 2, 891, 125, 3, 2, 2, 2, 892, 894, 
	9, 16, 2, 2, 893, 892, 3, 2, 2, 2, 894, 895, 3, 2, 2, 2, 895, 893, 3, 2, 
	2, 2, 895, 896, 3, 2, 2, 2, 896, 127, 3, 2, 2, 2, 897, 898, 5, 126, 64, 
	2, 898, 899, 7, 22, 2, 2, 899, 903, 7, 14, 2, 2, 900, 902, 11, 2, 2, 2, 
	901, 900, 3, 2, 2, 2, 902, 905, 3, 2, 2, 2, 903, 904, 3, 2, 2, 2, 903, 
	901, 3, 2, 2, 2, 904, 906, 3, 2, 2, 2, 905, 903, 3, 2, 2, 2, 906, 907, 
	7, 14, 2, 2, 907, 129, 3, 2, 2, 2, 908, 909, 5, 126, 64, 2, 909, 910, 7, 
	22, 2, 2, 910, 914, 7, 13, 2, 2, 911, 913, 11, 2, 2, 2, 912, 911, 3, 2, 
	2, 2, 913, 916, 3, 2, 2, 2, 914, 915, 3, 2, 2, 2, 914, 912, 3, 2, 2, 2, 
	915, 917, 3, 2, 2, 2, 916, 914, 3, 2, 2, 2, 917, 918, 7, 13, 2, 2, 918, 
	131, 3, 2, 2, 2, 919, 920, 7, 48, 2, 2, 920, 921, 7, 29, 2, 2, 921, 922, 
	7, 30, 2, 2, 922, 934, 7, 31, 2, 2, 923, 925, 9, 2, 2, 2, 924, 923, 3, 
	2, 2, 2, 925, 926, 3, 2, 2, 2, 926, 924, 3, 2, 2, 2, 926, 927, 3, 2, 2, 
	2, 927, 930, 3, 2, 2, 2, 928, 931, 5, 128, 65, 2, 929, 931, 5, 130, 66, 
	2, 930, 928, 3, 2, 2, 2, 930, 929, 3, 2, 2, 2, 931, 933, 3, 2, 2, 2, 932, 
	924, 3, 2, 2, 2, 933, 936, 3, 2, 2, 2, 934, 932, 3, 2, 2, 2, 934, 935, 
	3, 2, 2, 2, 935, 940, 3, 2, 2, 2, 936, 934, 3, 2, 2, 2, 937, 939, 9, 2, 
	2, 2, 938, 937, 3, 2, 2, 2, 939, 942, 3, 2, 2, 2, 940, 938, 3, 2, 2, 2, 
	940, 941, 3, 2, 2, 2, 941, 943, 3, 2, 2, 2, 942, 940, 3, 2, 2, 2, 943, 
	944, 7, 8, 2, 2, 944, 133, 3, 2, 2, 2, 945, 946, 7, 48, 2, 2, 946, 947, 
	7, 20, 2, 2, 947, 948, 7, 29, 2, 2, 948, 949, 7, 30, 2, 2, 949, 953, 7, 
	31, 2, 2, 950, 952, 9, 2, 2, 2, 951, 950, 3, 2, 2, 2, 952, 955, 3, 2, 2, 
	2, 953, 951, 3, 2, 2, 2, 953, 954, 3, 2, 2, 2, 954, 956, 3, 2, 2, 2, 955, 
	953, 3, 2, 2, 2, 956, 957, 7, 8, 2, 2, 957, 135, 3, 2, 2, 2, 958, 963, 
	5, 132, 67, 2, 959, 962, 5, 136, 69, 2, 960, 962, 11, 2, 2, 2, 961, 959, 
	3, 2, 2, 2, 961, 960, 3, 2, 2, 2, 962, 965, 3, 2, 2, 2, 963, 964, 3, 2, 
	2, 2, 963, 961, 3, 2, 2, 2, 964, 966, 3, 2, 2, 2, 965, 963, 3, 2, 2, 2, 
	966, 967, 5, 134, 68, 2, 967, 137, 3, 2, 2, 2, 968, 969, 7, 48, 2, 2, 969, 
	970, 7, 32, 2, 2, 970, 971, 7, 33, 2, 2, 971, 972, 7, 34, 2, 2, 972, 984, 
	7, 35, 2, 2, 973, 975, 9, 2, 2, 2, 974, 973, 3, 2, 2, 2, 975, 976, 3, 2, 
	2, 2, 976, 974, 3, 2, 2, 2, 976, 977, 3, 2, 2, 2, 977, 980, 3, 2, 2, 2, 
	978, 981, 5, 128, 65, 2, 979, 981, 5, 130, 66, 2, 980, 978, 3, 2, 2, 2, 
	980, 979, 3, 2, 2, 2, 981, 983, 3, 2, 2, 2, 982, 974, 3, 2, 2, 2, 983, 
	986, 3, 2, 2, 2, 984, 982, 3, 2, 2, 2, 984, 985, 3, 2, 2, 2, 985, 990, 
	3, 2, 2, 2, 986, 984, 3, 2, 2, 2, 987, 989, 9, 2, 2, 2, 988, 987, 3, 2, 
	2, 2, 989, 992, 3, 2, 2, 2, 990, 988, 3, 2, 2, 2, 990, 991, 3, 2, 2, 2, 
	991, 993, 3, 2, 2, 2, 992, 990, 3, 2, 2, 2, 993, 994, 7, 8, 2, 2, 994, 
	139, 3, 2, 2, 2, 995, 996, 7, 48, 2, 2, 996, 997, 7, 20, 2, 2, 997, 998, 
	7, 32, 2, 2, 998, 999, 7, 33, 2, 2, 999, 1000, 7, 34, 2, 2, 1000, 1004, 
	7, 35, 2, 2, 1001, 1003, 9, 2, 2, 2, 1002, 1001, 3, 2, 2, 2, 1003, 1006, 
	3, 2, 2, 2, 1004, 1002, 3, 2, 2, 2, 1004, 1005, 3, 2, 2, 2, 1005, 1007, 
	3, 2, 2, 2, 1006, 1004, 3, 2, 2, 2, 1007, 1008, 7, 8, 2, 2, 1008, 141, 
	3, 2, 2, 2, 1009, 1014, 5, 138, 70, 2, 1010, 1013, 5, 142, 72, 2, 1011, 
	1013, 11, 2, 2, 2, 1012, 1010, 3, 2, 2, 2, 1012, 1011, 3, 2, 2, 2, 1013, 
	1016, 3, 2, 2, 2, 1014, 1015, 3, 2, 2, 2, 1014, 1012, 3, 2, 2, 2, 1015, 
	1017, 3, 2, 2, 2, 1016, 1014, 3, 2, 2, 2, 1017, 1018, 5, 140, 71, 2, 1018, 
	143, 3, 2, 2, 2, 1019, 1020, 7, 48, 2, 2, 1020, 1021, 7, 36, 2, 2, 1021, 
	1033, 7, 37, 2, 2, 1022, 1024, 9, 2, 2, 2, 1023, 1022, 3, 2, 2, 2, 1024, 
	1025, 3, 2, 2, 2, 1025, 1023, 3, 2, 2, 2, 1025, 1026, 3, 2, 2, 2, 1026, 
	1029, 3, 2, 2, 2, 1027, 1030, 5, 128, 65, 2, 1028, 1030, 5, 130, 66, 2, 
	1029, 1027, 3, 2, 2, 2, 1029, 1028, 3, 2, 2, 2, 1030, 1032, 3, 2, 2, 2, 
	1031, 1023, 3, 2, 2, 2, 1032, 1035, 3, 2, 2, 2, 1033, 1031, 3, 2, 2, 2, 
	1033, 1034, 3, 2, 2, 2, 1034, 1039, 3, 2, 2, 2, 1035, 1033, 3, 2, 2, 2, 
	1036, 1038, 9, 2, 2, 2, 1037, 1036, 3, 2, 2, 2, 1038, 1041, 3, 2, 2, 2, 
	1039, 1037, 3, 2, 2, 2, 1039, 1040, 3, 2, 2, 2, 1040, 1043, 3, 2, 2, 2, 
	1041, 1039, 3, 2, 2, 2, 1042, 1044, 7, 20, 2, 2, 1043, 1042, 3, 2, 2, 2, 
	1043, 1044, 3, 2, 2, 2, 1044, 1048, 3, 2, 2, 2, 1045, 1047, 9, 2, 2, 2, 
	1046, 1045, 3, 2, 2, 2, 1047, 1050, 3, 2, 2, 2, 1048, 1046, 3, 2, 2, 2, 
	1048, 1049, 3, 2, 2, 2, 1049, 1051, 3, 2, 2, 2, 1050, 1048, 3, 2, 2, 2, 
	1051, 1052, 7, 8, 2, 2, 1052, 145, 3, 2, 2, 2, 1053, 1057, 5, 136, 69, 
	2, 1054, 1057, 5, 142, 72, 2, 1055, 1057, 5, 144, 73, 2, 1056, 1053, 3, 
	2, 2, 2, 1056, 1054, 3, 2, 2, 2, 1056, 1055, 3, 2, 2, 2, 1057, 147, 3, 
	2, 2, 2, 1058, 1059, 7, 48, 2, 2, 1059, 1071, 5, 126, 64, 2, 1060, 1062, 
	9, 2, 2, 2, 1061, 1060, 3, 2, 2, 2, 1062, 1063, 3, 2, 2, 2, 1063, 1061, 
	3, 2, 2, 2, 1063, 1064, 3, 2, 2, 2, 1064, 1067, 3, 2, 2, 2, 1065, 1068, 
	5, 128, 65, 2, 1066, 1068, 5, 130, 66, 2, 1067, 1065, 3, 2, 2, 2, 1067, 
	1066, 3, 2, 2, 2, 1068, 1070, 3, 2, 2, 2, 1069, 1061, 3, 2, 2, 2, 1070, 
	1073, 3, 2, 2, 2, 1071, 1069, 3, 2, 2, 2, 1071, 1072, 3, 2, 2, 2, 1072, 
	1077, 3, 2, 2, 2, 1073, 1071, 3, 2, 2, 2, 1074, 1076, 9, 2, 2, 2, 1075, 
	1074, 3, 2, 2, 2, 1076, 1079, 3, 2, 2, 2, 1077, 1075, 3, 2, 2, 2, 1077, 
	1078, 3, 2, 2, 2, 1078, 1080, 3, 2, 2, 2, 1079, 1077, 3, 2, 2, 2, 1080, 
	1081, 7, 20, 2, 2, 1081, 1082, 7, 8, 2, 2, 1082, 149, 3, 2, 2, 2, 1083, 
	1087, 7, 19, 2, 2, 1084, 1086, 11, 2, 2, 2, 1085, 1084, 3, 2, 2, 2, 1086, 
	1089, 3, 2, 2, 2, 1087, 1088, 3, 2, 2, 2, 1087, 1085, 3, 2, 2, 2, 1088, 
	1090, 3, 2, 2, 2, 1089, 1087, 3, 2, 2, 2, 1090, 1091, 7, 6, 2, 2, 1091, 
	1092, 7, 6, 2, 2, 1092, 1096, 7, 8, 2, 2, 1093, 1095, 9, 2, 2, 2, 1094, 
	1093, 3, 2, 2, 2, 1095, 1098, 3, 2, 2, 2, 1096, 1094, 3, 2, 2, 2, 1096, 
	1097, 3, 2, 2, 2, 1097, 1099, 3, 2, 2, 2, 1098, 1096, 3, 2, 2, 2, 1099, 
	1100, 9, 3, 2, 2, 1100, 151, 3, 2, 2, 2, 1101, 1103, 7, 48, 2, 2, 1102, 
	1104, 10, 17, 2, 2, 1103, 1102, 3, 2, 2, 2, 1104, 1105, 3, 2, 2, 2, 1105, 
	1103, 3, 2, 2, 2, 1105, 1106, 3, 2, 2, 2, 1106, 1107, 3, 2, 2, 2, 1107, 
	1108, 7, 8, 2, 2, 1108, 153, 3, 2, 2, 2, 147, 157, 162, 166, 171, 188, 
	194, 203, 210, 214, 220, 229, 239, 244, 247, 252, 255, 258, 265, 271, 274, 
	277, 281, 286, 291, 296, 301, 307, 313, 320, 324, 328, 333, 338, 342, 346, 
	351, 356, 360, 364, 369, 372, 377, 382, 390, 396, 401, 408, 411, 414, 419, 
	431, 437, 444, 446, 451, 457, 466, 475, 484, 490, 495, 501, 507, 513, 519, 
	528, 536, 540, 544, 546, 551, 557, 564, 570, 579, 587, 591, 595, 597, 603, 
	608, 614, 660, 672, 676, 683, 692, 698, 706, 717, 728, 735, 738, 746, 758, 
	764, 770, 775, 778, 783, 791, 795, 801, 810, 816, 820, 830, 837, 842, 847, 
	855, 863, 874, 886, 895, 903, 914, 926, 930, 934, 940, 953, 961, 963, 976, 
	980, 984, 990, 1004, 1012, 1014, 1025, 1029, 1033, 1039, 1043, 1048, 1056, 
	1063, 1067, 1071, 1077, 1087, 1096, 1105,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "' '", "'\t'", "'*'", "'-'", "'_'", "'>'", "'('", "')'", "'['", "']'", 
	"'\"'", "'''", "':'", "';'", "'@'", "'!'", "", "'/'", "'.'", "'='", "'&'", 
	"'\\'", "'`'", "'+'", "'{'", "'}'", "", "", "", "", "", "", "", "", "", 
	"", "", "", "'#'", "", "", "", "", "", "", "'<'",
}
var symbolicNames = []string{
	"", "SPACE", "TAB", "EMPH", "MINUS", "UNDERSCORE", "CLOSE_ANGLE_BRACKET", 
	"OPEN_PAREN", "CLOSE_PAREN", "OPEN_SB", "CLOSE_SB", "DOUBLE_QUOTE", "SINGLE_QUOTE", 
	"COLON", "SEMI_COLON", "AT", "EXCLAMATION_MARK", "HTML_COMMENT_OPEN", "SLASH", 
	"PERIOD", "EQUAL", "AMPERSAND", "BACKSLASH", "BACKTICK", "PLUS", "OPEN_CURLY", 
	"CLOSE_CURLY", "D", "I", "V", "S", "P", "A", "N", "H", "R", "SETEXT_BOTTOM_1", 
	"SETEXT_BOTTOM_2", "ATX_START", "SHARP", "LINE_BREAK", "BLANK_LINE", "NEWLINE", 
	"HEX_CHAR", "NORMAL_CHAR", "DIGIT", "OPEN_ANGLE_BRACKET", "SPECIAL_CHAR",
}

var ruleNames = []string{
	"document", "block", "htmlBlockTags", "htmlBlockSelfClosing", "heading", 
	"setextHeading", "setextHeading1", "setextHeading2", "atxHeading", "rawLine", 
	"nonIndentSpace", "blockQuote", "blockQuoteBlankLine", "verbatim", "verbatimBlankLine", 
	"horizontalRule", "references", "reference", "referenceLabel", "referenceId", 
	"referenceUrl", "referenceTitle", "referenceTitleSingle", "referenceTitleDouble", 
	"referenceTitleParens", "orderedList", "bulletList", "orderedListItem", 
	"bulletListItem", "inlineListItem", "listItemBlankLine", "para", "inline", 
	"span", "emph", "emphStar", "emphUl", "strong", "strongStar", "strongUl", 
	"image", "imageLink", "explicitImageLink", "imageAlt", "referenceImageLink", 
	"link", "linkContent", "explicitLink", "linkUrl", "linkTitle", "linkTitleSingle", 
	"linkTitleDouble", "referenceLink", "entity", "hexEntityName", "decEntityName", 
	"charEntityName", "escapedChar", "code", "backtickCode", "doubleBacktickCode", 
	"spaceBacktickCode", "attributeName", "htmlAttributeS", "htmlAttributeD", 
	"htmlBlockOpenDiv", "htmlBlockCloseDiv", "htmlBlockDiv", "htmlBlockOpenSpan", 
	"htmlBlockCloseSpan", "htmlBlockSpan", "htmlBlockHr", "htmlBlockInTags", 
	"htmlBlockInSelfClosing", "htmlComment", "autolink",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type MarkdownParser struct {
	*antlr.BaseParser
}

func NewMarkdownParser(input antlr.TokenStream) *MarkdownParser {
	this := new(MarkdownParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "MarkdownParser.g4"

	return this
}


private static final boolean debug = false;
private boolean tokenStartsWith(int la, String value) {
    Token t = _input.LT(la);
    return t.getText().startsWith(value);
}
private boolean tokenEndsWith(int la, String value) {
    Token t = _input.LT(la);
    return t.getText().endsWith(value);
}
private boolean tokenIs(int la, int type) {
    Token t = _input.LT(la);
    return t.getType() == type;
}
/**
 * Count spaces at the begin of the line.
 * Return int array with spaces at 0 and type at 1.
 * Return spaces -1 if not at the begin of the line.
 */
private int[] countSpaces(int index, int level, boolean skipBL) {
    int la = index;
    int[] retValue = new int[]{-1, -1};
    while (skipBL && _input.LT(la).getType() == BLANK_LINE) {
        la++;
    }
    if (_input.LT(la).getCharPositionInLine() != 0)
        return retValue;
    int spaces = 0;
    int type = 0;
    do {
        Token t = _input.LT(la++);
        type = t.getType();
        if (type == SPACE)
            spaces++;
        else if (type == TAB)
            spaces += 4;
	} while (type == SPACE || type == TAB);
	retValue[0] = spaces;
	retValue[1] = type;
	return retValue;
}
/* Redcarpet or the reference implementation Markdown.pl have tricky handling of spaces in front of list items.
 * Here I look at the pegdown implementation that simply counts spaces 0-3 level 0, 4-7 level1 ecc.
 * This way I should not track how many spaces each level has at the beginning.
 * For instance:
 *   * l0
 *  * l1
 *  * l1
 * for me is counter intuitive.
 */
private boolean followListItem(int index, int level) {
    return followListItem(index, level, false);
}
private boolean followListItem(int index, int level, boolean skipBL) {
    if (level < 0)
        return false;
    int[] spacesAndType = countSpaces(index, level, skipBL);
    int spaces = spacesAndType[0];
    int type = spacesAndType[1];
	int minSpaces = level*4;
	int maxSpaces = minSpaces+3;

	boolean retValue = spaces >= minSpaces && spaces <= maxSpaces;
	if (retValue) {   // Check also token type.
	    // TODO: checking for DIGIT is an incomplete check.
	    retValue = (type == EMPH || type == MINUS || type == PLUS || type == DIGIT);
	}
	if (debug)
	    System.out.println("followListItem(" + level
	    + "): line: " + _input.LT(index).getLine()
	    + ", skipBL: " + skipBL
	    + ", " + retValue);
	return retValue;
}
private boolean followVerbatim(int level) {
    return followVerbatim(level, false);
}
private boolean followVerbatim(int level, boolean skipBL) {
    if (level < 0)
        return false;
    int[] spacesAndType = countSpaces(1, level, skipBL);
    int spaces = spacesAndType[0];
	boolean retValue = spaces >= (level+1)*4;
    if (debug)
	    System.out.println("followVerbatim(" + level
	    + "): line: " + _input.LT(1).getLine()
	    + ", skipBL: " + skipBL
	    + ", " + retValue);

	return retValue;
}
// List item continuation should have same number of spaces of verbatim with the lower level.
private boolean followContinuation(int level) {
    return followContinuation(level, false);
}
private boolean followContinuation(int level, boolean skipBL) {
    if (level < 0)
        return false;
    int[] spacesAndType = countSpaces(1, level, skipBL);
    int spaces = spacesAndType[0];
	boolean retValue = spaces >= (level+1)*4;
    if (debug)
	    System.out.println("followContinuation(" + level
	    + "): line: " + _input.LT(1).getLine()
	    + ", skipBL: " + skipBL
	    + ", " + retValue);

	return retValue;
}
private boolean followBlockquote(int level) {
    if (level < 0)
        return false;
    int[] spacesAndType = countSpaces(1, level, true);
    int spaces = spacesAndType[0];
    int type = spacesAndType[1];
	int minSpaces = level*4;
	int maxSpaces = minSpaces+3;
	boolean retValue = spaces >= minSpaces && spaces <= maxSpaces && type == CLOSE_ANGLE_BRACKET;
    if (debug)
        System.out.println("followBlockquote(" + level
        + "): line: " + _input.LT(1).getLine()
        + ", " + retValue);

	return retValue;
}



// MarkdownParser tokens.
const (
	MarkdownParserEOF = antlr.TokenEOF
	MarkdownParserSPACE = 1
	MarkdownParserTAB = 2
	MarkdownParserEMPH = 3
	MarkdownParserMINUS = 4
	MarkdownParserUNDERSCORE = 5
	MarkdownParserCLOSE_ANGLE_BRACKET = 6
	MarkdownParserOPEN_PAREN = 7
	MarkdownParserCLOSE_PAREN = 8
	MarkdownParserOPEN_SB = 9
	MarkdownParserCLOSE_SB = 10
	MarkdownParserDOUBLE_QUOTE = 11
	MarkdownParserSINGLE_QUOTE = 12
	MarkdownParserCOLON = 13
	MarkdownParserSEMI_COLON = 14
	MarkdownParserAT = 15
	MarkdownParserEXCLAMATION_MARK = 16
	MarkdownParserHTML_COMMENT_OPEN = 17
	MarkdownParserSLASH = 18
	MarkdownParserPERIOD = 19
	MarkdownParserEQUAL = 20
	MarkdownParserAMPERSAND = 21
	MarkdownParserBACKSLASH = 22
	MarkdownParserBACKTICK = 23
	MarkdownParserPLUS = 24
	MarkdownParserOPEN_CURLY = 25
	MarkdownParserCLOSE_CURLY = 26
	MarkdownParserD = 27
	MarkdownParserI = 28
	MarkdownParserV = 29
	MarkdownParserS = 30
	MarkdownParserP = 31
	MarkdownParserA = 32
	MarkdownParserN = 33
	MarkdownParserH = 34
	MarkdownParserR = 35
	MarkdownParserSETEXT_BOTTOM_1 = 36
	MarkdownParserSETEXT_BOTTOM_2 = 37
	MarkdownParserATX_START = 38
	MarkdownParserSHARP = 39
	MarkdownParserLINE_BREAK = 40
	MarkdownParserBLANK_LINE = 41
	MarkdownParserNEWLINE = 42
	MarkdownParserHEX_CHAR = 43
	MarkdownParserNORMAL_CHAR = 44
	MarkdownParserDIGIT = 45
	MarkdownParserOPEN_ANGLE_BRACKET = 46
	MarkdownParserSPECIAL_CHAR = 47
)

// MarkdownParser rules.
const (
	MarkdownParserRULE_document = 0
	MarkdownParserRULE_block = 1
	MarkdownParserRULE_htmlBlockTags = 2
	MarkdownParserRULE_htmlBlockSelfClosing = 3
	MarkdownParserRULE_heading = 4
	MarkdownParserRULE_setextHeading = 5
	MarkdownParserRULE_setextHeading1 = 6
	MarkdownParserRULE_setextHeading2 = 7
	MarkdownParserRULE_atxHeading = 8
	MarkdownParserRULE_rawLine = 9
	MarkdownParserRULE_nonIndentSpace = 10
	MarkdownParserRULE_blockQuote = 11
	MarkdownParserRULE_blockQuoteBlankLine = 12
	MarkdownParserRULE_verbatim = 13
	MarkdownParserRULE_verbatimBlankLine = 14
	MarkdownParserRULE_horizontalRule = 15
	MarkdownParserRULE_references = 16
	MarkdownParserRULE_reference = 17
	MarkdownParserRULE_referenceLabel = 18
	MarkdownParserRULE_referenceId = 19
	MarkdownParserRULE_referenceUrl = 20
	MarkdownParserRULE_referenceTitle = 21
	MarkdownParserRULE_referenceTitleSingle = 22
	MarkdownParserRULE_referenceTitleDouble = 23
	MarkdownParserRULE_referenceTitleParens = 24
	MarkdownParserRULE_orderedList = 25
	MarkdownParserRULE_bulletList = 26
	MarkdownParserRULE_orderedListItem = 27
	MarkdownParserRULE_bulletListItem = 28
	MarkdownParserRULE_inlineListItem = 29
	MarkdownParserRULE_listItemBlankLine = 30
	MarkdownParserRULE_para = 31
	MarkdownParserRULE_inline = 32
	MarkdownParserRULE_span = 33
	MarkdownParserRULE_emph = 34
	MarkdownParserRULE_emphStar = 35
	MarkdownParserRULE_emphUl = 36
	MarkdownParserRULE_strong = 37
	MarkdownParserRULE_strongStar = 38
	MarkdownParserRULE_strongUl = 39
	MarkdownParserRULE_image = 40
	MarkdownParserRULE_imageLink = 41
	MarkdownParserRULE_explicitImageLink = 42
	MarkdownParserRULE_imageAlt = 43
	MarkdownParserRULE_referenceImageLink = 44
	MarkdownParserRULE_link = 45
	MarkdownParserRULE_linkContent = 46
	MarkdownParserRULE_explicitLink = 47
	MarkdownParserRULE_linkUrl = 48
	MarkdownParserRULE_linkTitle = 49
	MarkdownParserRULE_linkTitleSingle = 50
	MarkdownParserRULE_linkTitleDouble = 51
	MarkdownParserRULE_referenceLink = 52
	MarkdownParserRULE_entity = 53
	MarkdownParserRULE_hexEntityName = 54
	MarkdownParserRULE_decEntityName = 55
	MarkdownParserRULE_charEntityName = 56
	MarkdownParserRULE_escapedChar = 57
	MarkdownParserRULE_code = 58
	MarkdownParserRULE_backtickCode = 59
	MarkdownParserRULE_doubleBacktickCode = 60
	MarkdownParserRULE_spaceBacktickCode = 61
	MarkdownParserRULE_attributeName = 62
	MarkdownParserRULE_htmlAttributeS = 63
	MarkdownParserRULE_htmlAttributeD = 64
	MarkdownParserRULE_htmlBlockOpenDiv = 65
	MarkdownParserRULE_htmlBlockCloseDiv = 66
	MarkdownParserRULE_htmlBlockDiv = 67
	MarkdownParserRULE_htmlBlockOpenSpan = 68
	MarkdownParserRULE_htmlBlockCloseSpan = 69
	MarkdownParserRULE_htmlBlockSpan = 70
	MarkdownParserRULE_htmlBlockHr = 71
	MarkdownParserRULE_htmlBlockInTags = 72
	MarkdownParserRULE_htmlBlockInSelfClosing = 73
	MarkdownParserRULE_htmlComment = 74
	MarkdownParserRULE_autolink = 75
)

// IDocumentContext is an interface to support dynamic dispatch.
type IDocumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDocumentContext differentiates from other interfaces.
	IsDocumentContext()
}

type DocumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentContext() *DocumentContext {
	var p = new(DocumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_document
	return p
}

func (*DocumentContext) IsDocumentContext() {}

func NewDocumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DocumentContext {
	var p = new(DocumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_document

	return p
}

func (s *DocumentContext) GetParser() antlr.Parser { return s.parser }

func (s *DocumentContext) AllBlock() []IBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockContext)(nil)).Elem())
	var tst = make([]IBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockContext)
		}
	}

	return tst
}

func (s *DocumentContext) Block(i int) IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *DocumentContext) AllBLANK_LINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBLANK_LINE)
}

func (s *DocumentContext) BLANK_LINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBLANK_LINE, i)
}

func (s *DocumentContext) EOF() antlr.TerminalNode {
	return s.GetToken(MarkdownParserEOF, 0)
}

func (s *DocumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DocumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DocumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterDocument(s)
	}
}

func (s *DocumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitDocument(s)
	}
}




func (p *MarkdownParser) Document() (localctx IDocumentContext) {
	localctx = NewDocumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MarkdownParserRULE_document)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(153)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(152)
					p.Block()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(155)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())
	}
	p.SetState(160)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserBLANK_LINE {
		{
			p.SetState(157)
			p.Match(MarkdownParserBLANK_LINE)
		}


		p.SetState(162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(164)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(163)
			p.Match(MarkdownParserEOF)
		}


	}



	return localctx
}


// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) HtmlBlockTags() IHtmlBlockTagsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockTagsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockTagsContext)
}

func (s *BlockContext) HtmlBlockSelfClosing() IHtmlBlockSelfClosingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockSelfClosingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockSelfClosingContext)
}

func (s *BlockContext) HtmlComment() IHtmlCommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlCommentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlCommentContext)
}

func (s *BlockContext) Heading() IHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHeadingContext)
}

func (s *BlockContext) HorizontalRule() IHorizontalRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHorizontalRuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHorizontalRuleContext)
}

func (s *BlockContext) BlockQuote() IBlockQuoteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockQuoteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockQuoteContext)
}

func (s *BlockContext) References() IReferencesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferencesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferencesContext)
}

func (s *BlockContext) OrderedList() IOrderedListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderedListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderedListContext)
}

func (s *BlockContext) BulletList() IBulletListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBulletListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBulletListContext)
}

func (s *BlockContext) Verbatim() IVerbatimContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVerbatimContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVerbatimContext)
}

func (s *BlockContext) Para() IParaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParaContext)
}

func (s *BlockContext) AllBLANK_LINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBLANK_LINE)
}

func (s *BlockContext) BLANK_LINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBLANK_LINE, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitBlock(s)
	}
}




func (p *MarkdownParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MarkdownParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(169)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(166)
				p.Match(MarkdownParserBLANK_LINE)
			}


		}
		p.SetState(171)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}
	p.SetState(186)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(172)
			p.HtmlBlockTags()
		}


	case 2:
		{
			p.SetState(173)
			p.HtmlBlockSelfClosing()
		}


	case 3:
		{
			p.SetState(174)
			p.HtmlComment()
		}


	case 4:
		{
			p.SetState(175)
			p.Heading()
		}


	case 5:
		{
			p.SetState(176)
			p.HorizontalRule()
		}


	case 6:
		{
			p.SetState(177)
			p.BlockQuote(0)
		}


	case 7:
		{
			p.SetState(178)
			p.References()
		}


	case 8:
		p.SetState(179)

		if !(followListItem(1, 0)) {
			panic(antlr.NewFailedPredicateException(p, "followListItem(1, 0)", ""))
		}
		{
			p.SetState(180)
			p.OrderedList(0)
		}


	case 9:
		p.SetState(181)

		if !(followListItem(1, 0)) {
			panic(antlr.NewFailedPredicateException(p, "followListItem(1, 0)", ""))
		}
		{
			p.SetState(182)
			p.BulletList(0)
		}


	case 10:
		p.SetState(183)

		if !(followVerbatim(0)) {
			panic(antlr.NewFailedPredicateException(p, "followVerbatim(0)", ""))
		}
		{
			p.SetState(184)
			p.Verbatim(0)
		}


	case 11:
		{
			p.SetState(185)
			p.Para()
		}

	}



	return localctx
}


// IHtmlBlockTagsContext is an interface to support dynamic dispatch.
type IHtmlBlockTagsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockTagsContext differentiates from other interfaces.
	IsHtmlBlockTagsContext()
}

type HtmlBlockTagsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockTagsContext() *HtmlBlockTagsContext {
	var p = new(HtmlBlockTagsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockTags
	return p
}

func (*HtmlBlockTagsContext) IsHtmlBlockTagsContext() {}

func NewHtmlBlockTagsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockTagsContext {
	var p = new(HtmlBlockTagsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockTags

	return p
}

func (s *HtmlBlockTagsContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockTagsContext) HtmlBlockInTags() IHtmlBlockInTagsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockInTagsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockInTagsContext)
}

func (s *HtmlBlockTagsContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *HtmlBlockTagsContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserLINE_BREAK, 0)
}

func (s *HtmlBlockTagsContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HtmlBlockTagsContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HtmlBlockTagsContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HtmlBlockTagsContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HtmlBlockTagsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockTagsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockTagsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockTags(s)
	}
}

func (s *HtmlBlockTagsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockTags(s)
	}
}




func (p *MarkdownParser) HtmlBlockTags() (localctx IHtmlBlockTagsContext) {
	localctx = NewHtmlBlockTagsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MarkdownParserRULE_htmlBlockTags)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(188)
		p.HtmlBlockInTags()
	}
	p.SetState(192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(189)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(195)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MarkdownParserLINE_BREAK || _la == MarkdownParserNEWLINE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IHtmlBlockSelfClosingContext is an interface to support dynamic dispatch.
type IHtmlBlockSelfClosingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockSelfClosingContext differentiates from other interfaces.
	IsHtmlBlockSelfClosingContext()
}

type HtmlBlockSelfClosingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockSelfClosingContext() *HtmlBlockSelfClosingContext {
	var p = new(HtmlBlockSelfClosingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockSelfClosing
	return p
}

func (*HtmlBlockSelfClosingContext) IsHtmlBlockSelfClosingContext() {}

func NewHtmlBlockSelfClosingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockSelfClosingContext {
	var p = new(HtmlBlockSelfClosingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockSelfClosing

	return p
}

func (s *HtmlBlockSelfClosingContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockSelfClosingContext) HtmlBlockInSelfClosing() IHtmlBlockInSelfClosingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockInSelfClosingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockInSelfClosingContext)
}

func (s *HtmlBlockSelfClosingContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *HtmlBlockSelfClosingContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserLINE_BREAK, 0)
}

func (s *HtmlBlockSelfClosingContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HtmlBlockSelfClosingContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HtmlBlockSelfClosingContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HtmlBlockSelfClosingContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HtmlBlockSelfClosingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockSelfClosingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockSelfClosingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockSelfClosing(s)
	}
}

func (s *HtmlBlockSelfClosingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockSelfClosing(s)
	}
}




func (p *MarkdownParser) HtmlBlockSelfClosing() (localctx IHtmlBlockSelfClosingContext) {
	localctx = NewHtmlBlockSelfClosingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MarkdownParserRULE_htmlBlockSelfClosing)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(197)
		p.HtmlBlockInSelfClosing()
	}
	p.SetState(201)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(198)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(204)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MarkdownParserLINE_BREAK || _la == MarkdownParserNEWLINE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IHeadingContext is an interface to support dynamic dispatch.
type IHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHeadingContext differentiates from other interfaces.
	IsHeadingContext()
}

type HeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeadingContext() *HeadingContext {
	var p = new(HeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_heading
	return p
}

func (*HeadingContext) IsHeadingContext() {}

func NewHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HeadingContext {
	var p = new(HeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_heading

	return p
}

func (s *HeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *HeadingContext) SetextHeading() ISetextHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetextHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetextHeadingContext)
}

func (s *HeadingContext) AtxHeading() IAtxHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtxHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtxHeadingContext)
}

func (s *HeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHeading(s)
	}
}

func (s *HeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHeading(s)
	}
}




func (p *MarkdownParser) Heading() (localctx IHeadingContext) {
	localctx = NewHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MarkdownParserRULE_heading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(206)
			p.SetextHeading()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(207)
			p.AtxHeading()
		}

	}


	return localctx
}


// ISetextHeadingContext is an interface to support dynamic dispatch.
type ISetextHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetextHeadingContext differentiates from other interfaces.
	IsSetextHeadingContext()
}

type SetextHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetextHeadingContext() *SetextHeadingContext {
	var p = new(SetextHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_setextHeading
	return p
}

func (*SetextHeadingContext) IsSetextHeadingContext() {}

func NewSetextHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetextHeadingContext {
	var p = new(SetextHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_setextHeading

	return p
}

func (s *SetextHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *SetextHeadingContext) SetextHeading1() ISetextHeading1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetextHeading1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetextHeading1Context)
}

func (s *SetextHeadingContext) SetextHeading2() ISetextHeading2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetextHeading2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetextHeading2Context)
}

func (s *SetextHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetextHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetextHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterSetextHeading(s)
	}
}

func (s *SetextHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitSetextHeading(s)
	}
}




func (p *MarkdownParser) SetextHeading() (localctx ISetextHeadingContext) {
	localctx = NewSetextHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MarkdownParserRULE_setextHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(212)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(210)
			p.SetextHeading1()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(211)
			p.SetextHeading2()
		}

	}


	return localctx
}


// ISetextHeading1Context is an interface to support dynamic dispatch.
type ISetextHeading1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetextHeading1Context differentiates from other interfaces.
	IsSetextHeading1Context()
}

type SetextHeading1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetextHeading1Context() *SetextHeading1Context {
	var p = new(SetextHeading1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_setextHeading1
	return p
}

func (*SetextHeading1Context) IsSetextHeading1Context() {}

func NewSetextHeading1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetextHeading1Context {
	var p = new(SetextHeading1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_setextHeading1

	return p
}

func (s *SetextHeading1Context) GetParser() antlr.Parser { return s.parser }

func (s *SetextHeading1Context) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *SetextHeading1Context) SETEXT_BOTTOM_1() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSETEXT_BOTTOM_1, 0)
}

func (s *SetextHeading1Context) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *SetextHeading1Context) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *SetextHeading1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetextHeading1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetextHeading1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterSetextHeading1(s)
	}
}

func (s *SetextHeading1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitSetextHeading1(s)
	}
}




func (p *MarkdownParser) SetextHeading1() (localctx ISetextHeading1Context) {
	localctx = NewSetextHeading1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MarkdownParserRULE_setextHeading1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(216)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(214)

				if !(!tokenIs(1, NEWLINE)) {
					panic(antlr.NewFailedPredicateException(p, "!tokenIs(1, NEWLINE)", ""))
				}
				{
					p.SetState(215)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(218)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}
	{
		p.SetState(220)
		p.Match(MarkdownParserNEWLINE)
	}
	{
		p.SetState(221)
		p.Match(MarkdownParserSETEXT_BOTTOM_1)
	}



	return localctx
}


// ISetextHeading2Context is an interface to support dynamic dispatch.
type ISetextHeading2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetextHeading2Context differentiates from other interfaces.
	IsSetextHeading2Context()
}

type SetextHeading2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetextHeading2Context() *SetextHeading2Context {
	var p = new(SetextHeading2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_setextHeading2
	return p
}

func (*SetextHeading2Context) IsSetextHeading2Context() {}

func NewSetextHeading2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetextHeading2Context {
	var p = new(SetextHeading2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_setextHeading2

	return p
}

func (s *SetextHeading2Context) GetParser() antlr.Parser { return s.parser }

func (s *SetextHeading2Context) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *SetextHeading2Context) SETEXT_BOTTOM_2() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSETEXT_BOTTOM_2, 0)
}

func (s *SetextHeading2Context) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *SetextHeading2Context) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *SetextHeading2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetextHeading2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetextHeading2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterSetextHeading2(s)
	}
}

func (s *SetextHeading2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitSetextHeading2(s)
	}
}




func (p *MarkdownParser) SetextHeading2() (localctx ISetextHeading2Context) {
	localctx = NewSetextHeading2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MarkdownParserRULE_setextHeading2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(223)

				if !(!tokenIs(1, NEWLINE)) {
					panic(antlr.NewFailedPredicateException(p, "!tokenIs(1, NEWLINE)", ""))
				}
				{
					p.SetState(224)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext())
	}
	{
		p.SetState(229)
		p.Match(MarkdownParserNEWLINE)
	}
	{
		p.SetState(230)
		p.Match(MarkdownParserSETEXT_BOTTOM_2)
	}



	return localctx
}


// IAtxHeadingContext is an interface to support dynamic dispatch.
type IAtxHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtxHeadingContext differentiates from other interfaces.
	IsAtxHeadingContext()
}

type AtxHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtxHeadingContext() *AtxHeadingContext {
	var p = new(AtxHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_atxHeading
	return p
}

func (*AtxHeadingContext) IsAtxHeadingContext() {}

func NewAtxHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtxHeadingContext {
	var p = new(AtxHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_atxHeading

	return p
}

func (s *AtxHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *AtxHeadingContext) ATX_START() antlr.TerminalNode {
	return s.GetToken(MarkdownParserATX_START, 0)
}

func (s *AtxHeadingContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *AtxHeadingContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *AtxHeadingContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *AtxHeadingContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *AtxHeadingContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *AtxHeadingContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserLINE_BREAK, 0)
}

func (s *AtxHeadingContext) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *AtxHeadingContext) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *AtxHeadingContext) AllSHARP() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSHARP)
}

func (s *AtxHeadingContext) SHARP(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSHARP, i)
}

func (s *AtxHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtxHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AtxHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterAtxHeading(s)
	}
}

func (s *AtxHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitAtxHeading(s)
	}
}




func (p *MarkdownParser) AtxHeading() (localctx IAtxHeadingContext) {
	localctx = NewAtxHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MarkdownParserRULE_atxHeading)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(232)
		p.Match(MarkdownParserATX_START)
	}
	{
		p.SetState(233)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	_alt = 1+1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1+1:
				{
					p.SetState(234)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(237)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())
	}
	p.SetState(245)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
		p.SetState(242)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(239)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			}
			p.SetState(244)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
		}


	}
	p.SetState(253)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		p.SetState(250)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == MarkdownParserSHARP {
			{
				p.SetState(247)
				p.Match(MarkdownParserSHARP)
			}


			p.SetState(252)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}


	}
	p.SetState(256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(255)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(258)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MarkdownParserLINE_BREAK || _la == MarkdownParserNEWLINE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IRawLineContext is an interface to support dynamic dispatch.
type IRawLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRawLineContext differentiates from other interfaces.
	IsRawLineContext()
}

type RawLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRawLineContext() *RawLineContext {
	var p = new(RawLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_rawLine
	return p
}

func (*RawLineContext) IsRawLineContext() {}

func NewRawLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RawLineContext {
	var p = new(RawLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_rawLine

	return p
}

func (s *RawLineContext) GetParser() antlr.Parser { return s.parser }

func (s *RawLineContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *RawLineContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *RawLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RawLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RawLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterRawLine(s)
	}
}

func (s *RawLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitRawLine(s)
	}
}




func (p *MarkdownParser) RawLine() (localctx IRawLineContext) {
	localctx = NewRawLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MarkdownParserRULE_rawLine)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(260)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MarkdownParserNEWLINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(266)
		p.Match(MarkdownParserNEWLINE)
	}



	return localctx
}


// INonIndentSpaceContext is an interface to support dynamic dispatch.
type INonIndentSpaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonIndentSpaceContext differentiates from other interfaces.
	IsNonIndentSpaceContext()
}

type NonIndentSpaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonIndentSpaceContext() *NonIndentSpaceContext {
	var p = new(NonIndentSpaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_nonIndentSpace
	return p
}

func (*NonIndentSpaceContext) IsNonIndentSpaceContext() {}

func NewNonIndentSpaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonIndentSpaceContext {
	var p = new(NonIndentSpaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_nonIndentSpace

	return p
}

func (s *NonIndentSpaceContext) GetParser() antlr.Parser { return s.parser }

func (s *NonIndentSpaceContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *NonIndentSpaceContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *NonIndentSpaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonIndentSpaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NonIndentSpaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterNonIndentSpace(s)
	}
}

func (s *NonIndentSpaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitNonIndentSpace(s)
	}
}




func (p *MarkdownParser) NonIndentSpace() (localctx INonIndentSpaceContext) {
	localctx = NewNonIndentSpaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MarkdownParserRULE_nonIndentSpace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(269)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(268)
			p.Match(MarkdownParserSPACE)
		}


	}
	p.SetState(272)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(271)
			p.Match(MarkdownParserSPACE)
		}


	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(274)
			p.Match(MarkdownParserSPACE)
		}


	}



	return localctx
}


// IBlockQuoteContext is an interface to support dynamic dispatch.
type IBlockQuoteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_level returns the _level attribute.
	Get_level() int


	// Set_level sets the _level attribute.
	Set_level(int)


	// IsBlockQuoteContext differentiates from other interfaces.
	IsBlockQuoteContext()
}

type BlockQuoteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_level int
}

func NewEmptyBlockQuoteContext() *BlockQuoteContext {
	var p = new(BlockQuoteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_blockQuote
	return p
}

func (*BlockQuoteContext) IsBlockQuoteContext() {}

func NewBlockQuoteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, _level int) *BlockQuoteContext {
	var p = new(BlockQuoteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_blockQuote

	p._level = _level

	return p
}

func (s *BlockQuoteContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockQuoteContext) Get_level() int { return s._level }


func (s *BlockQuoteContext) Set_level(v int) { s._level = v }


func (s *BlockQuoteContext) AllCLOSE_ANGLE_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserCLOSE_ANGLE_BRACKET)
}

func (s *BlockQuoteContext) CLOSE_ANGLE_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, i)
}

func (s *BlockQuoteContext) AllRawLine() []IRawLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRawLineContext)(nil)).Elem())
	var tst = make([]IRawLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRawLineContext)
		}
	}

	return tst
}

func (s *BlockQuoteContext) RawLine(i int) IRawLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRawLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRawLineContext)
}

func (s *BlockQuoteContext) AllBlockQuoteBlankLine() []IBlockQuoteBlankLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockQuoteBlankLineContext)(nil)).Elem())
	var tst = make([]IBlockQuoteBlankLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockQuoteBlankLineContext)
		}
	}

	return tst
}

func (s *BlockQuoteContext) BlockQuoteBlankLine(i int) IBlockQuoteBlankLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockQuoteBlankLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockQuoteBlankLineContext)
}

func (s *BlockQuoteContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *BlockQuoteContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *BlockQuoteContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *BlockQuoteContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *BlockQuoteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockQuoteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BlockQuoteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterBlockQuote(s)
	}
}

func (s *BlockQuoteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitBlockQuote(s)
	}
}




func (p *MarkdownParser) BlockQuote(_level int) (localctx IBlockQuoteContext) {
	localctx = NewBlockQuoteContext(p, p.GetParserRuleContext(), p.GetState(), _level)
	p.EnterRule(localctx, 22, MarkdownParserRULE_blockQuote)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(277)

	if !(followBlockquote(localctx.(*BlockQuoteContext)._level)) {
		panic(antlr.NewFailedPredicateException(p, "followBlockquote($_level)", ""))
	}
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(279)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == MarkdownParserBLANK_LINE {
					{
						p.SetState(278)
						p.BlockQuoteBlankLine()
					}

				}
				p.SetState(284)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
					{
						p.SetState(281)
						_la = p.GetTokenStream().LA(1)

						if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}


					p.SetState(286)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(287)
					p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
				}
				p.SetState(289)
				p.GetErrorHandler().Sync(p)


				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(288)
						_la = p.GetTokenStream().LA(1)

						if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}


				}
				{
					p.SetState(291)
					p.RawLine()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
	}



	return localctx
}


// IBlockQuoteBlankLineContext is an interface to support dynamic dispatch.
type IBlockQuoteBlankLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockQuoteBlankLineContext differentiates from other interfaces.
	IsBlockQuoteBlankLineContext()
}

type BlockQuoteBlankLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockQuoteBlankLineContext() *BlockQuoteBlankLineContext {
	var p = new(BlockQuoteBlankLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_blockQuoteBlankLine
	return p
}

func (*BlockQuoteBlankLineContext) IsBlockQuoteBlankLineContext() {}

func NewBlockQuoteBlankLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockQuoteBlankLineContext {
	var p = new(BlockQuoteBlankLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_blockQuoteBlankLine

	return p
}

func (s *BlockQuoteBlankLineContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockQuoteBlankLineContext) AllBLANK_LINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBLANK_LINE)
}

func (s *BlockQuoteBlankLineContext) BLANK_LINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBLANK_LINE, i)
}

func (s *BlockQuoteBlankLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockQuoteBlankLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BlockQuoteBlankLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterBlockQuoteBlankLine(s)
	}
}

func (s *BlockQuoteBlankLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitBlockQuoteBlankLine(s)
	}
}




func (p *MarkdownParser) BlockQuoteBlankLine() (localctx IBlockQuoteBlankLineContext) {
	localctx = NewBlockQuoteBlankLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MarkdownParserRULE_blockQuoteBlankLine)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == MarkdownParserBLANK_LINE {
		{
			p.SetState(296)
			p.Match(MarkdownParserBLANK_LINE)
		}


		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IVerbatimContext is an interface to support dynamic dispatch.
type IVerbatimContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_level returns the _level attribute.
	Get_level() int


	// Set_level sets the _level attribute.
	Set_level(int)


	// IsVerbatimContext differentiates from other interfaces.
	IsVerbatimContext()
}

type VerbatimContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_level int
}

func NewEmptyVerbatimContext() *VerbatimContext {
	var p = new(VerbatimContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_verbatim
	return p
}

func (*VerbatimContext) IsVerbatimContext() {}

func NewVerbatimContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, _level int) *VerbatimContext {
	var p = new(VerbatimContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_verbatim

	p._level = _level

	return p
}

func (s *VerbatimContext) GetParser() antlr.Parser { return s.parser }

func (s *VerbatimContext) Get_level() int { return s._level }


func (s *VerbatimContext) Set_level(v int) { s._level = v }


func (s *VerbatimContext) AllRawLine() []IRawLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRawLineContext)(nil)).Elem())
	var tst = make([]IRawLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRawLineContext)
		}
	}

	return tst
}

func (s *VerbatimContext) RawLine(i int) IRawLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRawLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRawLineContext)
}

func (s *VerbatimContext) AllVerbatimBlankLine() []IVerbatimBlankLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVerbatimBlankLineContext)(nil)).Elem())
	var tst = make([]IVerbatimBlankLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVerbatimBlankLineContext)
		}
	}

	return tst
}

func (s *VerbatimContext) VerbatimBlankLine(i int) IVerbatimBlankLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVerbatimBlankLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVerbatimBlankLineContext)
}

func (s *VerbatimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VerbatimContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VerbatimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterVerbatim(s)
	}
}

func (s *VerbatimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitVerbatim(s)
	}
}




func (p *MarkdownParser) Verbatim(_level int) (localctx IVerbatimContext) {
	localctx = NewVerbatimContext(p, p.GetParserRuleContext(), p.GetState(), _level)
	p.EnterRule(localctx, 26, MarkdownParserRULE_verbatim)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(301)

				if !(followVerbatim(localctx.(*VerbatimContext)._level, true)) {
					panic(antlr.NewFailedPredicateException(p, "followVerbatim($_level, true)", ""))
				}
				p.SetState(305)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(302)
							p.VerbatimBlankLine()
						}


					}
					p.SetState(307)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())
				}
				{
					p.SetState(308)
					p.RawLine()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(311)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
	}



	return localctx
}


// IVerbatimBlankLineContext is an interface to support dynamic dispatch.
type IVerbatimBlankLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVerbatimBlankLineContext differentiates from other interfaces.
	IsVerbatimBlankLineContext()
}

type VerbatimBlankLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVerbatimBlankLineContext() *VerbatimBlankLineContext {
	var p = new(VerbatimBlankLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_verbatimBlankLine
	return p
}

func (*VerbatimBlankLineContext) IsVerbatimBlankLineContext() {}

func NewVerbatimBlankLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VerbatimBlankLineContext {
	var p = new(VerbatimBlankLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_verbatimBlankLine

	return p
}

func (s *VerbatimBlankLineContext) GetParser() antlr.Parser { return s.parser }

func (s *VerbatimBlankLineContext) BLANK_LINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserBLANK_LINE, 0)
}

func (s *VerbatimBlankLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VerbatimBlankLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VerbatimBlankLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterVerbatimBlankLine(s)
	}
}

func (s *VerbatimBlankLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitVerbatimBlankLine(s)
	}
}




func (p *MarkdownParser) VerbatimBlankLine() (localctx IVerbatimBlankLineContext) {
	localctx = NewVerbatimBlankLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MarkdownParserRULE_verbatimBlankLine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(313)
		p.Match(MarkdownParserBLANK_LINE)
	}



	return localctx
}


// IHorizontalRuleContext is an interface to support dynamic dispatch.
type IHorizontalRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHorizontalRuleContext differentiates from other interfaces.
	IsHorizontalRuleContext()
}

type HorizontalRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHorizontalRuleContext() *HorizontalRuleContext {
	var p = new(HorizontalRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_horizontalRule
	return p
}

func (*HorizontalRuleContext) IsHorizontalRuleContext() {}

func NewHorizontalRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HorizontalRuleContext {
	var p = new(HorizontalRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_horizontalRule

	return p
}

func (s *HorizontalRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *HorizontalRuleContext) NonIndentSpace() INonIndentSpaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonIndentSpaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonIndentSpaceContext)
}

func (s *HorizontalRuleContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *HorizontalRuleContext) AllEMPH() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserEMPH)
}

func (s *HorizontalRuleContext) EMPH(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserEMPH, i)
}

func (s *HorizontalRuleContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserMINUS)
}

func (s *HorizontalRuleContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserMINUS, i)
}

func (s *HorizontalRuleContext) AllUNDERSCORE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserUNDERSCORE)
}

func (s *HorizontalRuleContext) UNDERSCORE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserUNDERSCORE, i)
}

func (s *HorizontalRuleContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HorizontalRuleContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HorizontalRuleContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HorizontalRuleContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HorizontalRuleContext) SETEXT_BOTTOM_2() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSETEXT_BOTTOM_2, 0)
}

func (s *HorizontalRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HorizontalRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HorizontalRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHorizontalRule(s)
	}
}

func (s *HorizontalRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHorizontalRule(s)
	}
}




func (p *MarkdownParser) HorizontalRule() (localctx IHorizontalRuleContext) {
	localctx = NewHorizontalRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MarkdownParserRULE_horizontalRule)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MarkdownParserSPACE, MarkdownParserEMPH, MarkdownParserMINUS, MarkdownParserUNDERSCORE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(315)
			p.NonIndentSpace()
		}
		p.SetState(370)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MarkdownParserEMPH:
			{
				p.SetState(316)
				p.Match(MarkdownParserEMPH)
			}
			p.SetState(318)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(317)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(320)
				p.Match(MarkdownParserEMPH)
			}
			p.SetState(322)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(321)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(324)
				p.Match(MarkdownParserEMPH)
			}
			p.SetState(331)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH))) != 0) {
				p.SetState(326)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
					{
						p.SetState(325)
						_la = p.GetTokenStream().LA(1)

						if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				{
					p.SetState(328)
					p.Match(MarkdownParserEMPH)
				}


				p.SetState(333)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}


		case MarkdownParserMINUS:
			{
				p.SetState(334)
				p.Match(MarkdownParserMINUS)
			}
			p.SetState(336)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(335)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(338)
				p.Match(MarkdownParserMINUS)
			}
			p.SetState(340)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(339)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(342)
				p.Match(MarkdownParserMINUS)
			}
			p.SetState(349)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserMINUS))) != 0) {
				p.SetState(344)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
					{
						p.SetState(343)
						_la = p.GetTokenStream().LA(1)

						if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				{
					p.SetState(346)
					p.Match(MarkdownParserMINUS)
				}


				p.SetState(351)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}


		case MarkdownParserUNDERSCORE:
			{
				p.SetState(352)
				p.Match(MarkdownParserUNDERSCORE)
			}
			p.SetState(354)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(353)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(356)
				p.Match(MarkdownParserUNDERSCORE)
			}
			p.SetState(358)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(357)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(360)
				p.Match(MarkdownParserUNDERSCORE)
			}
			p.SetState(367)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserUNDERSCORE))) != 0) {
				p.SetState(362)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
					{
						p.SetState(361)
						_la = p.GetTokenStream().LA(1)

						if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				{
					p.SetState(364)
					p.Match(MarkdownParserUNDERSCORE)
				}


				p.SetState(369)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(372)
			p.Match(MarkdownParserNEWLINE)
		}


	case MarkdownParserSETEXT_BOTTOM_2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.Match(MarkdownParserSETEXT_BOTTOM_2)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IReferencesContext is an interface to support dynamic dispatch.
type IReferencesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferencesContext differentiates from other interfaces.
	IsReferencesContext()
}

type ReferencesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferencesContext() *ReferencesContext {
	var p = new(ReferencesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_references
	return p
}

func (*ReferencesContext) IsReferencesContext() {}

func NewReferencesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferencesContext {
	var p = new(ReferencesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_references

	return p
}

func (s *ReferencesContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferencesContext) AllReference() []IReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReferenceContext)(nil)).Elem())
	var tst = make([]IReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReferenceContext)
		}
	}

	return tst
}

func (s *ReferencesContext) Reference(i int) IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *ReferencesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferencesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferencesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferences(s)
	}
}

func (s *ReferencesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferences(s)
	}
}




func (p *MarkdownParser) References() (localctx IReferencesContext) {
	localctx = NewReferencesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MarkdownParserRULE_references)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(378)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(377)
					p.Reference()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())
	}



	return localctx
}


// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_reference
	return p
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) NonIndentSpace() INonIndentSpaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonIndentSpaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonIndentSpaceContext)
}

func (s *ReferenceContext) ReferenceLabel() IReferenceLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceLabelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceLabelContext)
}

func (s *ReferenceContext) COLON() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCOLON, 0)
}

func (s *ReferenceContext) ReferenceUrl() IReferenceUrlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceUrlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceUrlContext)
}

func (s *ReferenceContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *ReferenceContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *ReferenceContext) ReferenceTitle() IReferenceTitleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTitleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTitleContext)
}

func (s *ReferenceContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *ReferenceContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *ReferenceContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *ReferenceContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReference(s)
	}
}

func (s *ReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReference(s)
	}
}




func (p *MarkdownParser) Reference() (localctx IReferenceContext) {
	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MarkdownParserRULE_reference)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)
		p.NonIndentSpace()
	}
	{
		p.SetState(383)
		p.ReferenceLabel()
	}
	{
		p.SetState(384)
		p.Match(MarkdownParserCOLON)
	}
	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(385)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(390)
		p.ReferenceUrl()
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
		case 1:
			p.SetState(392)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(391)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


				p.SetState(394)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}


		case 2:
			p.SetState(399)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(396)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


				p.SetState(401)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(402)
				p.Match(MarkdownParserNEWLINE)
			}
			p.SetState(406)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(403)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


				p.SetState(408)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(411)
			p.ReferenceTitle()
		}


	}
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(414)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(420)
		p.Match(MarkdownParserNEWLINE)
	}



	return localctx
}


// IReferenceLabelContext is an interface to support dynamic dispatch.
type IReferenceLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceLabelContext differentiates from other interfaces.
	IsReferenceLabelContext()
}

type ReferenceLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceLabelContext() *ReferenceLabelContext {
	var p = new(ReferenceLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_referenceLabel
	return p
}

func (*ReferenceLabelContext) IsReferenceLabelContext() {}

func NewReferenceLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceLabelContext {
	var p = new(ReferenceLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_referenceLabel

	return p
}

func (s *ReferenceLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceLabelContext) OPEN_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_SB, 0)
}

func (s *ReferenceLabelContext) ReferenceId() IReferenceIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceIdContext)
}

func (s *ReferenceLabelContext) CLOSE_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_SB, 0)
}

func (s *ReferenceLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferenceLabel(s)
	}
}

func (s *ReferenceLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferenceLabel(s)
	}
}




func (p *MarkdownParser) ReferenceLabel() (localctx IReferenceLabelContext) {
	localctx = NewReferenceLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MarkdownParserRULE_referenceLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.Match(MarkdownParserOPEN_SB)
	}
	{
		p.SetState(423)
		p.ReferenceId()
	}
	{
		p.SetState(424)
		p.Match(MarkdownParserCLOSE_SB)
	}



	return localctx
}


// IReferenceIdContext is an interface to support dynamic dispatch.
type IReferenceIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceIdContext differentiates from other interfaces.
	IsReferenceIdContext()
}

type ReferenceIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceIdContext() *ReferenceIdContext {
	var p = new(ReferenceIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_referenceId
	return p
}

func (*ReferenceIdContext) IsReferenceIdContext() {}

func NewReferenceIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceIdContext {
	var p = new(ReferenceIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_referenceId

	return p
}

func (s *ReferenceIdContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceIdContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *ReferenceIdContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *ReferenceIdContext) AllCLOSE_SB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserCLOSE_SB)
}

func (s *ReferenceIdContext) CLOSE_SB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_SB, i)
}

func (s *ReferenceIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferenceId(s)
	}
}

func (s *ReferenceIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferenceId(s)
	}
}




func (p *MarkdownParser) ReferenceId() (localctx IReferenceIdContext) {
	localctx = NewReferenceIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MarkdownParserRULE_referenceId)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(426)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MarkdownParserCLOSE_SB || _la == MarkdownParserNEWLINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IReferenceUrlContext is an interface to support dynamic dispatch.
type IReferenceUrlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceUrlContext differentiates from other interfaces.
	IsReferenceUrlContext()
}

type ReferenceUrlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceUrlContext() *ReferenceUrlContext {
	var p = new(ReferenceUrlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_referenceUrl
	return p
}

func (*ReferenceUrlContext) IsReferenceUrlContext() {}

func NewReferenceUrlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceUrlContext {
	var p = new(ReferenceUrlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_referenceUrl

	return p
}

func (s *ReferenceUrlContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceUrlContext) AllOPEN_ANGLE_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserOPEN_ANGLE_BRACKET)
}

func (s *ReferenceUrlContext) OPEN_ANGLE_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, i)
}

func (s *ReferenceUrlContext) AllCLOSE_ANGLE_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserCLOSE_ANGLE_BRACKET)
}

func (s *ReferenceUrlContext) CLOSE_ANGLE_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, i)
}

func (s *ReferenceUrlContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *ReferenceUrlContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *ReferenceUrlContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *ReferenceUrlContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *ReferenceUrlContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *ReferenceUrlContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *ReferenceUrlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceUrlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceUrlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferenceUrl(s)
	}
}

func (s *ReferenceUrlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferenceUrl(s)
	}
}




func (p *MarkdownParser) ReferenceUrl() (localctx IReferenceUrlContext) {
	localctx = NewReferenceUrlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MarkdownParserRULE_referenceUrl)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(444)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MarkdownParserOPEN_ANGLE_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(431)
			p.Match(MarkdownParserOPEN_ANGLE_BRACKET)
		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())

		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(432)
				p.MatchWildcard()



			}
			p.SetState(437)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
		}
		{
			p.SetState(438)
			p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
		}


	case MarkdownParserEMPH, MarkdownParserMINUS, MarkdownParserUNDERSCORE, MarkdownParserOPEN_PAREN, MarkdownParserCLOSE_PAREN, MarkdownParserOPEN_SB, MarkdownParserCLOSE_SB, MarkdownParserDOUBLE_QUOTE, MarkdownParserSINGLE_QUOTE, MarkdownParserCOLON, MarkdownParserSEMI_COLON, MarkdownParserAT, MarkdownParserEXCLAMATION_MARK, MarkdownParserHTML_COMMENT_OPEN, MarkdownParserSLASH, MarkdownParserPERIOD, MarkdownParserEQUAL, MarkdownParserAMPERSAND, MarkdownParserBACKSLASH, MarkdownParserBACKTICK, MarkdownParserPLUS, MarkdownParserOPEN_CURLY, MarkdownParserCLOSE_CURLY, MarkdownParserD, MarkdownParserI, MarkdownParserV, MarkdownParserS, MarkdownParserP, MarkdownParserA, MarkdownParserN, MarkdownParserH, MarkdownParserR, MarkdownParserSETEXT_BOTTOM_1, MarkdownParserSETEXT_BOTTOM_2, MarkdownParserATX_START, MarkdownParserSHARP, MarkdownParserLINE_BREAK, MarkdownParserBLANK_LINE, MarkdownParserHEX_CHAR, MarkdownParserNORMAL_CHAR, MarkdownParserDIGIT, MarkdownParserSPECIAL_CHAR:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
			{
				p.SetState(439)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET))) != 0) || _la == MarkdownParserNEWLINE || _la == MarkdownParserOPEN_ANGLE_BRACKET  {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


			p.SetState(442)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IReferenceTitleContext is an interface to support dynamic dispatch.
type IReferenceTitleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceTitleContext differentiates from other interfaces.
	IsReferenceTitleContext()
}

type ReferenceTitleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceTitleContext() *ReferenceTitleContext {
	var p = new(ReferenceTitleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_referenceTitle
	return p
}

func (*ReferenceTitleContext) IsReferenceTitleContext() {}

func NewReferenceTitleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceTitleContext {
	var p = new(ReferenceTitleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_referenceTitle

	return p
}

func (s *ReferenceTitleContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceTitleContext) ReferenceTitleSingle() IReferenceTitleSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTitleSingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTitleSingleContext)
}

func (s *ReferenceTitleContext) ReferenceTitleDouble() IReferenceTitleDoubleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTitleDoubleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTitleDoubleContext)
}

func (s *ReferenceTitleContext) ReferenceTitleParens() IReferenceTitleParensContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceTitleParensContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceTitleParensContext)
}

func (s *ReferenceTitleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceTitleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceTitleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferenceTitle(s)
	}
}

func (s *ReferenceTitleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferenceTitle(s)
	}
}




func (p *MarkdownParser) ReferenceTitle() (localctx IReferenceTitleContext) {
	localctx = NewReferenceTitleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MarkdownParserRULE_referenceTitle)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(449)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MarkdownParserSINGLE_QUOTE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(446)
			p.ReferenceTitleSingle()
		}


	case MarkdownParserDOUBLE_QUOTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(447)
			p.ReferenceTitleDouble()
		}


	case MarkdownParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(448)
			p.ReferenceTitleParens()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IReferenceTitleSingleContext is an interface to support dynamic dispatch.
type IReferenceTitleSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceTitleSingleContext differentiates from other interfaces.
	IsReferenceTitleSingleContext()
}

type ReferenceTitleSingleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceTitleSingleContext() *ReferenceTitleSingleContext {
	var p = new(ReferenceTitleSingleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_referenceTitleSingle
	return p
}

func (*ReferenceTitleSingleContext) IsReferenceTitleSingleContext() {}

func NewReferenceTitleSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceTitleSingleContext {
	var p = new(ReferenceTitleSingleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_referenceTitleSingle

	return p
}

func (s *ReferenceTitleSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceTitleSingleContext) AllSINGLE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSINGLE_QUOTE)
}

func (s *ReferenceTitleSingleContext) SINGLE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSINGLE_QUOTE, i)
}

func (s *ReferenceTitleSingleContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *ReferenceTitleSingleContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *ReferenceTitleSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceTitleSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceTitleSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferenceTitleSingle(s)
	}
}

func (s *ReferenceTitleSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferenceTitleSingle(s)
	}
}




func (p *MarkdownParser) ReferenceTitleSingle() (localctx IReferenceTitleSingleContext) {
	localctx = NewReferenceTitleSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MarkdownParserRULE_referenceTitleSingle)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(MarkdownParserSINGLE_QUOTE)
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(452)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MarkdownParserSINGLE_QUOTE || _la == MarkdownParserNEWLINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(458)
		p.Match(MarkdownParserSINGLE_QUOTE)
	}



	return localctx
}


// IReferenceTitleDoubleContext is an interface to support dynamic dispatch.
type IReferenceTitleDoubleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceTitleDoubleContext differentiates from other interfaces.
	IsReferenceTitleDoubleContext()
}

type ReferenceTitleDoubleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceTitleDoubleContext() *ReferenceTitleDoubleContext {
	var p = new(ReferenceTitleDoubleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_referenceTitleDouble
	return p
}

func (*ReferenceTitleDoubleContext) IsReferenceTitleDoubleContext() {}

func NewReferenceTitleDoubleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceTitleDoubleContext {
	var p = new(ReferenceTitleDoubleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_referenceTitleDouble

	return p
}

func (s *ReferenceTitleDoubleContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceTitleDoubleContext) AllDOUBLE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserDOUBLE_QUOTE)
}

func (s *ReferenceTitleDoubleContext) DOUBLE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserDOUBLE_QUOTE, i)
}

func (s *ReferenceTitleDoubleContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *ReferenceTitleDoubleContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *ReferenceTitleDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceTitleDoubleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceTitleDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferenceTitleDouble(s)
	}
}

func (s *ReferenceTitleDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferenceTitleDouble(s)
	}
}




func (p *MarkdownParser) ReferenceTitleDouble() (localctx IReferenceTitleDoubleContext) {
	localctx = NewReferenceTitleDoubleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MarkdownParserRULE_referenceTitleDouble)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(460)
		p.Match(MarkdownParserDOUBLE_QUOTE)
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(461)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MarkdownParserDOUBLE_QUOTE || _la == MarkdownParserNEWLINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(467)
		p.Match(MarkdownParserDOUBLE_QUOTE)
	}



	return localctx
}


// IReferenceTitleParensContext is an interface to support dynamic dispatch.
type IReferenceTitleParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceTitleParensContext differentiates from other interfaces.
	IsReferenceTitleParensContext()
}

type ReferenceTitleParensContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceTitleParensContext() *ReferenceTitleParensContext {
	var p = new(ReferenceTitleParensContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_referenceTitleParens
	return p
}

func (*ReferenceTitleParensContext) IsReferenceTitleParensContext() {}

func NewReferenceTitleParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceTitleParensContext {
	var p = new(ReferenceTitleParensContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_referenceTitleParens

	return p
}

func (s *ReferenceTitleParensContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceTitleParensContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_PAREN, 0)
}

func (s *ReferenceTitleParensContext) AllCLOSE_PAREN() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserCLOSE_PAREN)
}

func (s *ReferenceTitleParensContext) CLOSE_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_PAREN, i)
}

func (s *ReferenceTitleParensContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *ReferenceTitleParensContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *ReferenceTitleParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceTitleParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceTitleParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferenceTitleParens(s)
	}
}

func (s *ReferenceTitleParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferenceTitleParens(s)
	}
}




func (p *MarkdownParser) ReferenceTitleParens() (localctx IReferenceTitleParensContext) {
	localctx = NewReferenceTitleParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MarkdownParserRULE_referenceTitleParens)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(MarkdownParserOPEN_PAREN)
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(470)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MarkdownParserCLOSE_PAREN || _la == MarkdownParserNEWLINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(476)
		p.Match(MarkdownParserCLOSE_PAREN)
	}



	return localctx
}


// IOrderedListContext is an interface to support dynamic dispatch.
type IOrderedListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_level returns the _level attribute.
	Get_level() int

	// GetNextItemWithPar returns the nextItemWithPar attribute.
	GetNextItemWithPar() boolean


	// Set_level sets the _level attribute.
	Set_level(int)

	// SetNextItemWithPar sets the nextItemWithPar attribute.
	SetNextItemWithPar(boolean)


	// IsOrderedListContext differentiates from other interfaces.
	IsOrderedListContext()
}

type OrderedListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_level int
	nextItemWithPar boolean
}

func NewEmptyOrderedListContext() *OrderedListContext {
	var p = new(OrderedListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_orderedList
	return p
}

func (*OrderedListContext) IsOrderedListContext() {}

func NewOrderedListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, _level int) *OrderedListContext {
	var p = new(OrderedListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_orderedList

	p._level = _level

	return p
}

func (s *OrderedListContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderedListContext) Get_level() int { return s._level }

func (s *OrderedListContext) GetNextItemWithPar() boolean { return s.nextItemWithPar }


func (s *OrderedListContext) Set_level(v int) { s._level = v }

func (s *OrderedListContext) SetNextItemWithPar(v boolean) { s.nextItemWithPar = v }


func (s *OrderedListContext) AllOrderedListItem() []IOrderedListItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderedListItemContext)(nil)).Elem())
	var tst = make([]IOrderedListItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderedListItemContext)
		}
	}

	return tst
}

func (s *OrderedListContext) OrderedListItem(i int) IOrderedListItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderedListItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderedListItemContext)
}

func (s *OrderedListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderedListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrderedListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterOrderedList(s)
	}
}

func (s *OrderedListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitOrderedList(s)
	}
}




func (p *MarkdownParser) OrderedList(_level int) (localctx IOrderedListContext) {
	localctx = NewOrderedListContext(p, p.GetParserRuleContext(), p.GetState(), _level)
	p.EnterRule(localctx, 50, MarkdownParserRULE_orderedList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(480)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(478)

				if !(followListItem(1, localctx.(*OrderedListContext)._level, true)) {
					panic(antlr.NewFailedPredicateException(p, "followListItem(1, $_level, true)", ""))
				}
				{
					p.SetState(479)
					p.OrderedListItem(_level)
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(482)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext())
	}



	return localctx
}


// IBulletListContext is an interface to support dynamic dispatch.
type IBulletListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_level returns the _level attribute.
	Get_level() int

	// GetNextItemWithPar returns the nextItemWithPar attribute.
	GetNextItemWithPar() boolean


	// Set_level sets the _level attribute.
	Set_level(int)

	// SetNextItemWithPar sets the nextItemWithPar attribute.
	SetNextItemWithPar(boolean)


	// IsBulletListContext differentiates from other interfaces.
	IsBulletListContext()
}

type BulletListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_level int
	nextItemWithPar boolean
}

func NewEmptyBulletListContext() *BulletListContext {
	var p = new(BulletListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_bulletList
	return p
}

func (*BulletListContext) IsBulletListContext() {}

func NewBulletListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, _level int) *BulletListContext {
	var p = new(BulletListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_bulletList

	p._level = _level

	return p
}

func (s *BulletListContext) GetParser() antlr.Parser { return s.parser }

func (s *BulletListContext) Get_level() int { return s._level }

func (s *BulletListContext) GetNextItemWithPar() boolean { return s.nextItemWithPar }


func (s *BulletListContext) Set_level(v int) { s._level = v }

func (s *BulletListContext) SetNextItemWithPar(v boolean) { s.nextItemWithPar = v }


func (s *BulletListContext) AllBulletListItem() []IBulletListItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBulletListItemContext)(nil)).Elem())
	var tst = make([]IBulletListItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBulletListItemContext)
		}
	}

	return tst
}

func (s *BulletListContext) BulletListItem(i int) IBulletListItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBulletListItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBulletListItemContext)
}

func (s *BulletListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulletListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BulletListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterBulletList(s)
	}
}

func (s *BulletListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitBulletList(s)
	}
}




func (p *MarkdownParser) BulletList(_level int) (localctx IBulletListContext) {
	localctx = NewBulletListContext(p, p.GetParserRuleContext(), p.GetState(), _level)
	p.EnterRule(localctx, 52, MarkdownParserRULE_bulletList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(484)

				if !(followListItem(1, localctx.(*BulletListContext)._level, true)) {
					panic(antlr.NewFailedPredicateException(p, "followListItem(1, $_level, true)", ""))
				}
				{
					p.SetState(485)
					p.BulletListItem(_level)
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
	}



	return localctx
}


// IOrderedListItemContext is an interface to support dynamic dispatch.
type IOrderedListItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_level returns the _level attribute.
	Get_level() int

	// GetIsWithPar returns the isWithPar attribute.
	GetIsWithPar() boolean


	// Set_level sets the _level attribute.
	Set_level(int)

	// SetIsWithPar sets the isWithPar attribute.
	SetIsWithPar(boolean)


	// IsOrderedListItemContext differentiates from other interfaces.
	IsOrderedListItemContext()
}

type OrderedListItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_level int
	isWithPar boolean
}

func NewEmptyOrderedListItemContext() *OrderedListItemContext {
	var p = new(OrderedListItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_orderedListItem
	return p
}

func (*OrderedListItemContext) IsOrderedListItemContext() {}

func NewOrderedListItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, _level int) *OrderedListItemContext {
	var p = new(OrderedListItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_orderedListItem

	p._level = _level

	return p
}

func (s *OrderedListItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderedListItemContext) Get_level() int { return s._level }

func (s *OrderedListItemContext) GetIsWithPar() boolean { return s.isWithPar }


func (s *OrderedListItemContext) Set_level(v int) { s._level = v }

func (s *OrderedListItemContext) SetIsWithPar(v boolean) { s.isWithPar = v }


func (s *OrderedListItemContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(MarkdownParserPERIOD, 0)
}

func (s *OrderedListItemContext) AllInlineListItem() []IInlineListItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineListItemContext)(nil)).Elem())
	var tst = make([]IInlineListItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineListItemContext)
		}
	}

	return tst
}

func (s *OrderedListItemContext) InlineListItem(i int) IInlineListItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineListItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineListItemContext)
}

func (s *OrderedListItemContext) AllBLANK_LINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBLANK_LINE)
}

func (s *OrderedListItemContext) BLANK_LINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBLANK_LINE, i)
}

func (s *OrderedListItemContext) AllDIGIT() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserDIGIT)
}

func (s *OrderedListItemContext) DIGIT(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserDIGIT, i)
}

func (s *OrderedListItemContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *OrderedListItemContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *OrderedListItemContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *OrderedListItemContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *OrderedListItemContext) AllOrderedList() []IOrderedListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderedListContext)(nil)).Elem())
	var tst = make([]IOrderedListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderedListContext)
		}
	}

	return tst
}

func (s *OrderedListItemContext) OrderedList(i int) IOrderedListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderedListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderedListContext)
}

func (s *OrderedListItemContext) AllBulletList() []IBulletListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBulletListContext)(nil)).Elem())
	var tst = make([]IBulletListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBulletListContext)
		}
	}

	return tst
}

func (s *OrderedListItemContext) BulletList(i int) IBulletListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBulletListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBulletListContext)
}

func (s *OrderedListItemContext) AllListItemBlankLine() []IListItemBlankLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IListItemBlankLineContext)(nil)).Elem())
	var tst = make([]IListItemBlankLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IListItemBlankLineContext)
		}
	}

	return tst
}

func (s *OrderedListItemContext) ListItemBlankLine(i int) IListItemBlankLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListItemBlankLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IListItemBlankLineContext)
}

func (s *OrderedListItemContext) AllVerbatim() []IVerbatimContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVerbatimContext)(nil)).Elem())
	var tst = make([]IVerbatimContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVerbatimContext)
		}
	}

	return tst
}

func (s *OrderedListItemContext) Verbatim(i int) IVerbatimContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVerbatimContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVerbatimContext)
}

func (s *OrderedListItemContext) AllBlockQuote() []IBlockQuoteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockQuoteContext)(nil)).Elem())
	var tst = make([]IBlockQuoteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockQuoteContext)
		}
	}

	return tst
}

func (s *OrderedListItemContext) BlockQuote(i int) IBlockQuoteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockQuoteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockQuoteContext)
}

func (s *OrderedListItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderedListItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrderedListItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterOrderedListItem(s)
	}
}

func (s *OrderedListItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitOrderedListItem(s)
	}
}




func (p *MarkdownParser) OrderedListItem(_level int) (localctx IOrderedListItemContext) {
	localctx = NewOrderedListItemContext(p, p.GetParserRuleContext(), p.GetState(), _level)
	p.EnterRule(localctx, 54, MarkdownParserRULE_orderedListItem)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserBLANK_LINE {
		{
			p.SetState(490)
			p.Match(MarkdownParserBLANK_LINE)
		}


		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(499)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(496)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == MarkdownParserDIGIT {
		{
			p.SetState(502)
			p.Match(MarkdownParserDIGIT)
		}


		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(507)
		p.Match(MarkdownParserPERIOD)
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(508)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}
	{
		p.SetState(513)
		p.InlineListItem(_level)
	}
	p.SetState(544)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		p.SetState(514)

		if !(followListItem(1, localctx.(*OrderedListItemContext)._level+1)) {
			panic(antlr.NewFailedPredicateException(p, "followListItem(1, $_level+1)", ""))
		}
		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(515)
				p.OrderedList(_level+1)
			}


		case 2:
			{
				p.SetState(516)
				p.BulletList(_level+1)
			}

		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 2 {
		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					p.SetState(519)

					if !(followVerbatim(localctx.(*OrderedListItemContext)._level+1, true) || followListItem(1, localctx.(*OrderedListItemContext)._level+1, true) || followContinuation(localctx.(*OrderedListItemContext)._level, true)) {
						panic(antlr.NewFailedPredicateException(p, "followVerbatim($_level+1, true) || followListItem(1, $_level+1, true) || followContinuation($_level, true)", ""))
					}
					{
						p.SetState(520)
						p.ListItemBlankLine()
					}
					p.SetState(538)
					p.GetErrorHandler().Sync(p)
					switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
					case 1:
						p.SetState(521)

						if !(followVerbatim(localctx.(*OrderedListItemContext)._level+1, true)) {
							panic(antlr.NewFailedPredicateException(p, "followVerbatim($_level+1, true)", ""))
						}
						{
							p.SetState(522)
							p.Verbatim(_level+1)
						}


					case 2:
						p.SetState(523)

						if !(followListItem(1, localctx.(*OrderedListItemContext)._level+1, true)) {
							panic(antlr.NewFailedPredicateException(p, "followListItem(1, $_level+1, true)", ""))
						}
						p.SetState(526)
						p.GetErrorHandler().Sync(p)
						switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
						case 1:
							{
								p.SetState(524)
								p.OrderedList(_level+1)
							}


						case 2:
							{
								p.SetState(525)
								p.BulletList(_level+1)
							}

						}


					case 3:
						p.SetState(528)

						if !(followBlockquote(localctx.(*OrderedListItemContext)._level+1)) {
							panic(antlr.NewFailedPredicateException(p, "followBlockquote($_level+1)", ""))
						}
						{
							p.SetState(529)
							p.BlockQuote(_level+1)
						}


					case 4:
						p.SetState(530)

						if !(followContinuation(localctx.(*OrderedListItemContext)._level, true)) {
							panic(antlr.NewFailedPredicateException(p, "followContinuation($_level, true)", ""))
						}
						p.SetState(534)
						p.GetErrorHandler().Sync(p)
						_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

						for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
							if _alt == 1 {
								{
									p.SetState(531)
									_la = p.GetTokenStream().LA(1)

									if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
										p.GetErrorHandler().RecoverInline(p)
									} else {
										p.GetErrorHandler().ReportMatch(p)
										p.Consume()
									}
								}


							}
							p.SetState(536)
							p.GetErrorHandler().Sync(p)
							_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
						}
						{
							p.SetState(537)
							p.InlineListItem(_level)
						}

					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(542)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
		}


	}



	return localctx
}


// IBulletListItemContext is an interface to support dynamic dispatch.
type IBulletListItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_level returns the _level attribute.
	Get_level() int

	// GetIsWithPar returns the isWithPar attribute.
	GetIsWithPar() boolean


	// Set_level sets the _level attribute.
	Set_level(int)

	// SetIsWithPar sets the isWithPar attribute.
	SetIsWithPar(boolean)


	// IsBulletListItemContext differentiates from other interfaces.
	IsBulletListItemContext()
}

type BulletListItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_level int
	isWithPar boolean
}

func NewEmptyBulletListItemContext() *BulletListItemContext {
	var p = new(BulletListItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_bulletListItem
	return p
}

func (*BulletListItemContext) IsBulletListItemContext() {}

func NewBulletListItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, _level int) *BulletListItemContext {
	var p = new(BulletListItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_bulletListItem

	p._level = _level

	return p
}

func (s *BulletListItemContext) GetParser() antlr.Parser { return s.parser }

func (s *BulletListItemContext) Get_level() int { return s._level }

func (s *BulletListItemContext) GetIsWithPar() boolean { return s.isWithPar }


func (s *BulletListItemContext) Set_level(v int) { s._level = v }

func (s *BulletListItemContext) SetIsWithPar(v boolean) { s.isWithPar = v }


func (s *BulletListItemContext) AllInlineListItem() []IInlineListItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineListItemContext)(nil)).Elem())
	var tst = make([]IInlineListItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineListItemContext)
		}
	}

	return tst
}

func (s *BulletListItemContext) InlineListItem(i int) IInlineListItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineListItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineListItemContext)
}

func (s *BulletListItemContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MarkdownParserPLUS, 0)
}

func (s *BulletListItemContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MarkdownParserMINUS, 0)
}

func (s *BulletListItemContext) EMPH() antlr.TerminalNode {
	return s.GetToken(MarkdownParserEMPH, 0)
}

func (s *BulletListItemContext) AllBLANK_LINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBLANK_LINE)
}

func (s *BulletListItemContext) BLANK_LINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBLANK_LINE, i)
}

func (s *BulletListItemContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *BulletListItemContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *BulletListItemContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *BulletListItemContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *BulletListItemContext) AllOrderedList() []IOrderedListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderedListContext)(nil)).Elem())
	var tst = make([]IOrderedListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderedListContext)
		}
	}

	return tst
}

func (s *BulletListItemContext) OrderedList(i int) IOrderedListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderedListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderedListContext)
}

func (s *BulletListItemContext) AllBulletList() []IBulletListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBulletListContext)(nil)).Elem())
	var tst = make([]IBulletListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBulletListContext)
		}
	}

	return tst
}

func (s *BulletListItemContext) BulletList(i int) IBulletListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBulletListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBulletListContext)
}

func (s *BulletListItemContext) AllListItemBlankLine() []IListItemBlankLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IListItemBlankLineContext)(nil)).Elem())
	var tst = make([]IListItemBlankLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IListItemBlankLineContext)
		}
	}

	return tst
}

func (s *BulletListItemContext) ListItemBlankLine(i int) IListItemBlankLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListItemBlankLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IListItemBlankLineContext)
}

func (s *BulletListItemContext) AllVerbatim() []IVerbatimContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVerbatimContext)(nil)).Elem())
	var tst = make([]IVerbatimContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVerbatimContext)
		}
	}

	return tst
}

func (s *BulletListItemContext) Verbatim(i int) IVerbatimContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVerbatimContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVerbatimContext)
}

func (s *BulletListItemContext) AllBlockQuote() []IBlockQuoteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockQuoteContext)(nil)).Elem())
	var tst = make([]IBlockQuoteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockQuoteContext)
		}
	}

	return tst
}

func (s *BulletListItemContext) BlockQuote(i int) IBlockQuoteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockQuoteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockQuoteContext)
}

func (s *BulletListItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulletListItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BulletListItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterBulletListItem(s)
	}
}

func (s *BulletListItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitBulletListItem(s)
	}
}




func (p *MarkdownParser) BulletListItem(_level int) (localctx IBulletListItemContext) {
	localctx = NewBulletListItemContext(p, p.GetParserRuleContext(), p.GetState(), _level)
	p.EnterRule(localctx, 56, MarkdownParserRULE_bulletListItem)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(549)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserBLANK_LINE {
		{
			p.SetState(546)
			p.Match(MarkdownParserBLANK_LINE)
		}


		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(552)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(557)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(558)
		_la = p.GetTokenStream().LA(1)

		if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserPLUS))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(559)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
	}
	{
		p.SetState(564)
		p.InlineListItem(_level)
	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		p.SetState(565)

		if !(followListItem(1, localctx.(*BulletListItemContext)._level+1)) {
			panic(antlr.NewFailedPredicateException(p, "followListItem(1, $_level+1)", ""))
		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(566)
				p.OrderedList(_level+1)
			}


		case 2:
			{
				p.SetState(567)
				p.BulletList(_level+1)
			}

		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 2 {
		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					p.SetState(570)

					if !(followVerbatim(localctx.(*BulletListItemContext)._level+1, true) || followListItem(1, localctx.(*BulletListItemContext)._level+1, true) || followContinuation(localctx.(*BulletListItemContext)._level, true)) {
						panic(antlr.NewFailedPredicateException(p, "followVerbatim($_level+1, true) || followListItem(1, $_level+1, true) || followContinuation($_level, true)", ""))
					}
					{
						p.SetState(571)
						p.ListItemBlankLine()
					}
					p.SetState(589)
					p.GetErrorHandler().Sync(p)
					switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
					case 1:
						p.SetState(572)

						if !(followVerbatim(localctx.(*BulletListItemContext)._level+1, true)) {
							panic(antlr.NewFailedPredicateException(p, "followVerbatim($_level+1, true)", ""))
						}
						{
							p.SetState(573)
							p.Verbatim(_level+1)
						}


					case 2:
						p.SetState(574)

						if !(followListItem(1, localctx.(*BulletListItemContext)._level+1, true)) {
							panic(antlr.NewFailedPredicateException(p, "followListItem(1, $_level+1, true)", ""))
						}
						p.SetState(577)
						p.GetErrorHandler().Sync(p)
						switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
						case 1:
							{
								p.SetState(575)
								p.OrderedList(_level+1)
							}


						case 2:
							{
								p.SetState(576)
								p.BulletList(_level+1)
							}

						}


					case 3:
						p.SetState(579)

						if !(followBlockquote(localctx.(*BulletListItemContext)._level+1)) {
							panic(antlr.NewFailedPredicateException(p, "followBlockquote($_level+1)", ""))
						}
						{
							p.SetState(580)
							p.BlockQuote(_level+1)
						}


					case 4:
						p.SetState(581)

						if !(followContinuation(localctx.(*BulletListItemContext)._level, true)) {
							panic(antlr.NewFailedPredicateException(p, "followContinuation($_level, true)", ""))
						}
						p.SetState(585)
						p.GetErrorHandler().Sync(p)
						_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

						for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
							if _alt == 1 {
								{
									p.SetState(582)
									_la = p.GetTokenStream().LA(1)

									if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
										p.GetErrorHandler().RecoverInline(p)
									} else {
										p.GetErrorHandler().ReportMatch(p)
										p.Consume()
									}
								}


							}
							p.SetState(587)
							p.GetErrorHandler().Sync(p)
							_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
						}
						{
							p.SetState(588)
							p.InlineListItem(_level)
						}

					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(593)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())
		}


	}



	return localctx
}


// IInlineListItemContext is an interface to support dynamic dispatch.
type IInlineListItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_level returns the _level attribute.
	Get_level() int


	// Set_level sets the _level attribute.
	Set_level(int)


	// IsInlineListItemContext differentiates from other interfaces.
	IsInlineListItemContext()
}

type InlineListItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_level int
}

func NewEmptyInlineListItemContext() *InlineListItemContext {
	var p = new(InlineListItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_inlineListItem
	return p
}

func (*InlineListItemContext) IsInlineListItemContext() {}

func NewInlineListItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, _level int) *InlineListItemContext {
	var p = new(InlineListItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_inlineListItem

	p._level = _level

	return p
}

func (s *InlineListItemContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineListItemContext) Get_level() int { return s._level }


func (s *InlineListItemContext) Set_level(v int) { s._level = v }


func (s *InlineListItemContext) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *InlineListItemContext) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *InlineListItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineListItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InlineListItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterInlineListItem(s)
	}
}

func (s *InlineListItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitInlineListItem(s)
	}
}




func (p *MarkdownParser) InlineListItem(_level int) (localctx IInlineListItemContext) {
	localctx = NewInlineListItemContext(p, p.GetParserRuleContext(), p.GetState(), _level)
	p.EnterRule(localctx, 58, MarkdownParserRULE_inlineListItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(599)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(597)

				if !(!followListItem(1, localctx.(*InlineListItemContext)._level) && !followListItem(1, localctx.(*InlineListItemContext)._level-1) && !followListItem(1, localctx.(*InlineListItemContext)._level+1)) {
					panic(antlr.NewFailedPredicateException(p, "!followListItem(1, $_level) && !followListItem(1, $_level-1) && !followListItem(1, $_level+1)", ""))
				}
				{
					p.SetState(598)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())
	}



	return localctx
}


// IListItemBlankLineContext is an interface to support dynamic dispatch.
type IListItemBlankLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListItemBlankLineContext differentiates from other interfaces.
	IsListItemBlankLineContext()
}

type ListItemBlankLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListItemBlankLineContext() *ListItemBlankLineContext {
	var p = new(ListItemBlankLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_listItemBlankLine
	return p
}

func (*ListItemBlankLineContext) IsListItemBlankLineContext() {}

func NewListItemBlankLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListItemBlankLineContext {
	var p = new(ListItemBlankLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_listItemBlankLine

	return p
}

func (s *ListItemBlankLineContext) GetParser() antlr.Parser { return s.parser }

func (s *ListItemBlankLineContext) AllBLANK_LINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBLANK_LINE)
}

func (s *ListItemBlankLineContext) BLANK_LINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBLANK_LINE, i)
}

func (s *ListItemBlankLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListItemBlankLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ListItemBlankLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterListItemBlankLine(s)
	}
}

func (s *ListItemBlankLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitListItemBlankLine(s)
	}
}




func (p *MarkdownParser) ListItemBlankLine() (localctx IListItemBlankLineContext) {
	localctx = NewListItemBlankLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MarkdownParserRULE_listItemBlankLine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(603)
					p.Match(MarkdownParserBLANK_LINE)
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
	}



	return localctx
}


// IParaContext is an interface to support dynamic dispatch.
type IParaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParaContext differentiates from other interfaces.
	IsParaContext()
}

type ParaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParaContext() *ParaContext {
	var p = new(ParaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_para
	return p
}

func (*ParaContext) IsParaContext() {}

func NewParaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParaContext {
	var p = new(ParaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_para

	return p
}

func (s *ParaContext) GetParser() antlr.Parser { return s.parser }

func (s *ParaContext) NonIndentSpace() INonIndentSpaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonIndentSpaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonIndentSpaceContext)
}

func (s *ParaContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *ParaContext) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *ParaContext) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *ParaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterPara(s)
	}
}

func (s *ParaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitPara(s)
	}
}




func (p *MarkdownParser) Para() (localctx IParaContext) {
	localctx = NewParaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MarkdownParserRULE_para)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.NonIndentSpace()
	}
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(609)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
	}
	{
		p.SetState(614)
		p.Match(MarkdownParserNEWLINE)
	}



	return localctx
}


// IInlineContext is an interface to support dynamic dispatch.
type IInlineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInlineContext differentiates from other interfaces.
	IsInlineContext()
}

type InlineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineContext() *InlineContext {
	var p = new(InlineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_inline
	return p
}

func (*InlineContext) IsInlineContext() {}

func NewInlineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineContext {
	var p = new(InlineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_inline

	return p
}

func (s *InlineContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineContext) Span() ISpanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpanContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpanContext)
}

func (s *InlineContext) HEX_CHAR() antlr.TerminalNode {
	return s.GetToken(MarkdownParserHEX_CHAR, 0)
}

func (s *InlineContext) NORMAL_CHAR() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNORMAL_CHAR, 0)
}

func (s *InlineContext) DIGIT() antlr.TerminalNode {
	return s.GetToken(MarkdownParserDIGIT, 0)
}

func (s *InlineContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *InlineContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserLINE_BREAK, 0)
}

func (s *InlineContext) SPACE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, 0)
}

func (s *InlineContext) TAB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, 0)
}

func (s *InlineContext) SPECIAL_CHAR() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPECIAL_CHAR, 0)
}

func (s *InlineContext) EMPH() antlr.TerminalNode {
	return s.GetToken(MarkdownParserEMPH, 0)
}

func (s *InlineContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserUNDERSCORE, 0)
}

func (s *InlineContext) COLON() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCOLON, 0)
}

func (s *InlineContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSEMI_COLON, 0)
}

func (s *InlineContext) SLASH() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSLASH, 0)
}

func (s *InlineContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(MarkdownParserPERIOD, 0)
}

func (s *InlineContext) OPEN_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, 0)
}

func (s *InlineContext) CLOSE_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, 0)
}

func (s *InlineContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_PAREN, 0)
}

func (s *InlineContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_PAREN, 0)
}

func (s *InlineContext) EXCLAMATION_MARK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserEXCLAMATION_MARK, 0)
}

func (s *InlineContext) SHARP() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSHARP, 0)
}

func (s *InlineContext) OPEN_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_SB, 0)
}

func (s *InlineContext) CLOSE_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_SB, 0)
}

func (s *InlineContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(MarkdownParserAMPERSAND, 0)
}

func (s *InlineContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(MarkdownParserBACKSLASH, 0)
}

func (s *InlineContext) SINGLE_QUOTE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSINGLE_QUOTE, 0)
}

func (s *InlineContext) DOUBLE_QUOTE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserDOUBLE_QUOTE, 0)
}

func (s *InlineContext) BACKTICK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserBACKTICK, 0)
}

func (s *InlineContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MarkdownParserPLUS, 0)
}

func (s *InlineContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MarkdownParserMINUS, 0)
}

func (s *InlineContext) OPEN_CURLY() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_CURLY, 0)
}

func (s *InlineContext) CLOSE_CURLY() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_CURLY, 0)
}

func (s *InlineContext) D() antlr.TerminalNode {
	return s.GetToken(MarkdownParserD, 0)
}

func (s *InlineContext) I() antlr.TerminalNode {
	return s.GetToken(MarkdownParserI, 0)
}

func (s *InlineContext) V() antlr.TerminalNode {
	return s.GetToken(MarkdownParserV, 0)
}

func (s *InlineContext) S() antlr.TerminalNode {
	return s.GetToken(MarkdownParserS, 0)
}

func (s *InlineContext) P() antlr.TerminalNode {
	return s.GetToken(MarkdownParserP, 0)
}

func (s *InlineContext) A() antlr.TerminalNode {
	return s.GetToken(MarkdownParserA, 0)
}

func (s *InlineContext) N() antlr.TerminalNode {
	return s.GetToken(MarkdownParserN, 0)
}

func (s *InlineContext) H() antlr.TerminalNode {
	return s.GetToken(MarkdownParserH, 0)
}

func (s *InlineContext) R() antlr.TerminalNode {
	return s.GetToken(MarkdownParserR, 0)
}

func (s *InlineContext) AT() antlr.TerminalNode {
	return s.GetToken(MarkdownParserAT, 0)
}

func (s *InlineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InlineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterInline(s)
	}
}

func (s *InlineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitInline(s)
	}
}




func (p *MarkdownParser) Inline() (localctx IInlineContext) {
	localctx = NewInlineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MarkdownParserRULE_inline)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(616)
			p.Span()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(617)
			p.Match(MarkdownParserHEX_CHAR)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(618)
			p.Match(MarkdownParserNORMAL_CHAR)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(619)
			p.Match(MarkdownParserDIGIT)
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(620)
			p.Match(MarkdownParserNEWLINE)
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(621)
			p.Match(MarkdownParserLINE_BREAK)
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(622)
			p.Match(MarkdownParserSPACE)
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(623)
			p.Match(MarkdownParserTAB)
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(624)
			p.Match(MarkdownParserSPECIAL_CHAR)
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(625)
			p.Match(MarkdownParserEMPH)
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(626)
			p.Match(MarkdownParserUNDERSCORE)
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(627)
			p.Match(MarkdownParserCOLON)
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(628)
			p.Match(MarkdownParserSEMI_COLON)
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(629)
			p.Match(MarkdownParserSLASH)
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(630)
			p.Match(MarkdownParserPERIOD)
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(631)
			p.Match(MarkdownParserOPEN_ANGLE_BRACKET)
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(632)
			p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(633)
			p.Match(MarkdownParserOPEN_PAREN)
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(634)
			p.Match(MarkdownParserCLOSE_PAREN)
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(635)
			p.Match(MarkdownParserEXCLAMATION_MARK)
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(636)
			p.Match(MarkdownParserSHARP)
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(637)
			p.Match(MarkdownParserOPEN_SB)
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(638)
			p.Match(MarkdownParserCLOSE_SB)
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(639)
			p.Match(MarkdownParserAMPERSAND)
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(640)
			p.Match(MarkdownParserBACKSLASH)
		}


	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(641)
			p.Match(MarkdownParserSINGLE_QUOTE)
		}


	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(642)
			p.Match(MarkdownParserDOUBLE_QUOTE)
		}


	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(643)
			p.Match(MarkdownParserBACKTICK)
		}


	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(644)
			p.Match(MarkdownParserPLUS)
		}


	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(645)
			p.Match(MarkdownParserMINUS)
		}


	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(646)
			p.Match(MarkdownParserOPEN_CURLY)
		}


	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(647)
			p.Match(MarkdownParserCLOSE_CURLY)
		}


	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(648)
			p.Match(MarkdownParserD)
		}


	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(649)
			p.Match(MarkdownParserI)
		}


	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(650)
			p.Match(MarkdownParserV)
		}


	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(651)
			p.Match(MarkdownParserS)
		}


	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(652)
			p.Match(MarkdownParserP)
		}


	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(653)
			p.Match(MarkdownParserA)
		}


	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(654)
			p.Match(MarkdownParserN)
		}


	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(655)
			p.Match(MarkdownParserH)
		}


	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(656)
			p.Match(MarkdownParserR)
		}


	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(657)
			p.Match(MarkdownParserAT)
		}

	}


	return localctx
}


// ISpanContext is an interface to support dynamic dispatch.
type ISpanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpanContext differentiates from other interfaces.
	IsSpanContext()
}

type SpanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpanContext() *SpanContext {
	var p = new(SpanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_span
	return p
}

func (*SpanContext) IsSpanContext() {}

func NewSpanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpanContext {
	var p = new(SpanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_span

	return p
}

func (s *SpanContext) GetParser() antlr.Parser { return s.parser }

func (s *SpanContext) Strong() IStrongContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrongContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrongContext)
}

func (s *SpanContext) Emph() IEmphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmphContext)
}

func (s *SpanContext) Image() IImageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImageContext)
}

func (s *SpanContext) Link() ILinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkContext)
}

func (s *SpanContext) Code() ICodeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeContext)
}

func (s *SpanContext) HtmlBlockInTags() IHtmlBlockInTagsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockInTagsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockInTagsContext)
}

func (s *SpanContext) HtmlBlockInSelfClosing() IHtmlBlockInSelfClosingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockInSelfClosingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockInSelfClosingContext)
}

func (s *SpanContext) Autolink() IAutolinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAutolinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAutolinkContext)
}

func (s *SpanContext) Entity() IEntityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntityContext)
}

func (s *SpanContext) EscapedChar() IEscapedCharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedCharContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEscapedCharContext)
}

func (s *SpanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SpanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterSpan(s)
	}
}

func (s *SpanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitSpan(s)
	}
}




func (p *MarkdownParser) Span() (localctx ISpanContext) {
	localctx = NewSpanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MarkdownParserRULE_span)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(660)
			p.Strong()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(661)
			p.Emph()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(662)
			p.Image()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(663)
			p.Link()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(664)
			p.Code()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(665)
			p.HtmlBlockInTags()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(666)
			p.HtmlBlockInSelfClosing()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(667)
			p.Autolink()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(668)
			p.Entity()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(669)
			p.EscapedChar()
		}

	}


	return localctx
}


// IEmphContext is an interface to support dynamic dispatch.
type IEmphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmphContext differentiates from other interfaces.
	IsEmphContext()
}

type EmphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmphContext() *EmphContext {
	var p = new(EmphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_emph
	return p
}

func (*EmphContext) IsEmphContext() {}

func NewEmphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmphContext {
	var p = new(EmphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_emph

	return p
}

func (s *EmphContext) GetParser() antlr.Parser { return s.parser }

func (s *EmphContext) EmphStar() IEmphStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmphStarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmphStarContext)
}

func (s *EmphContext) EmphUl() IEmphUlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmphUlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmphUlContext)
}

func (s *EmphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EmphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterEmph(s)
	}
}

func (s *EmphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitEmph(s)
	}
}




func (p *MarkdownParser) Emph() (localctx IEmphContext) {
	localctx = NewEmphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MarkdownParserRULE_emph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(672)
			p.EmphStar()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(673)
			p.EmphUl()
		}

	}


	return localctx
}


// IEmphStarContext is an interface to support dynamic dispatch.
type IEmphStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmphStarContext differentiates from other interfaces.
	IsEmphStarContext()
}

type EmphStarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmphStarContext() *EmphStarContext {
	var p = new(EmphStarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_emphStar
	return p
}

func (*EmphStarContext) IsEmphStarContext() {}

func NewEmphStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmphStarContext {
	var p = new(EmphStarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_emphStar

	return p
}

func (s *EmphStarContext) GetParser() antlr.Parser { return s.parser }

func (s *EmphStarContext) AllEMPH() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserEMPH)
}

func (s *EmphStarContext) EMPH(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserEMPH, i)
}

func (s *EmphStarContext) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *EmphStarContext) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *EmphStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmphStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EmphStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterEmphStar(s)
	}
}

func (s *EmphStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitEmphStar(s)
	}
}




func (p *MarkdownParser) EmphStar() (localctx IEmphStarContext) {
	localctx = NewEmphStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MarkdownParserRULE_emphStar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(676)

	if !(!tokenStartsWith(2, " ") && !tokenIs(2, EMPH)) {
		panic(antlr.NewFailedPredicateException(p, "!tokenStartsWith(2, \" \") && !tokenIs(2, EMPH)", ""))
	}
	{
		p.SetState(677)
		p.Match(MarkdownParserEMPH)
	}
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	_alt = 1+1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1+1:
				{
					p.SetState(678)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(681)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())
	}
	{
		p.SetState(683)
		p.Match(MarkdownParserEMPH)
	}



	return localctx
}


// IEmphUlContext is an interface to support dynamic dispatch.
type IEmphUlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmphUlContext differentiates from other interfaces.
	IsEmphUlContext()
}

type EmphUlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmphUlContext() *EmphUlContext {
	var p = new(EmphUlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_emphUl
	return p
}

func (*EmphUlContext) IsEmphUlContext() {}

func NewEmphUlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmphUlContext {
	var p = new(EmphUlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_emphUl

	return p
}

func (s *EmphUlContext) GetParser() antlr.Parser { return s.parser }

func (s *EmphUlContext) AllUNDERSCORE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserUNDERSCORE)
}

func (s *EmphUlContext) UNDERSCORE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserUNDERSCORE, i)
}

func (s *EmphUlContext) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *EmphUlContext) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *EmphUlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmphUlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EmphUlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterEmphUl(s)
	}
}

func (s *EmphUlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitEmphUl(s)
	}
}




func (p *MarkdownParser) EmphUl() (localctx IEmphUlContext) {
	localctx = NewEmphUlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MarkdownParserRULE_emphUl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(685)

	if !(!tokenStartsWith(2, " ") && !tokenIs(2, UNDERSCORE)) {
		panic(antlr.NewFailedPredicateException(p, "!tokenStartsWith(2, \" \") && !tokenIs(2, UNDERSCORE)", ""))
	}
	{
		p.SetState(686)
		p.Match(MarkdownParserUNDERSCORE)
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(687)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())
	}
	{
		p.SetState(692)
		p.Match(MarkdownParserUNDERSCORE)
	}



	return localctx
}


// IStrongContext is an interface to support dynamic dispatch.
type IStrongContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrongContext differentiates from other interfaces.
	IsStrongContext()
}

type StrongContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrongContext() *StrongContext {
	var p = new(StrongContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_strong
	return p
}

func (*StrongContext) IsStrongContext() {}

func NewStrongContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrongContext {
	var p = new(StrongContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_strong

	return p
}

func (s *StrongContext) GetParser() antlr.Parser { return s.parser }

func (s *StrongContext) StrongStar() IStrongStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrongStarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrongStarContext)
}

func (s *StrongContext) StrongUl() IStrongUlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrongUlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrongUlContext)
}

func (s *StrongContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrongContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StrongContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterStrong(s)
	}
}

func (s *StrongContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitStrong(s)
	}
}




func (p *MarkdownParser) Strong() (localctx IStrongContext) {
	localctx = NewStrongContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MarkdownParserRULE_strong)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(694)
			p.StrongStar()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(695)
			p.StrongUl()
		}

	}


	return localctx
}


// IStrongStarContext is an interface to support dynamic dispatch.
type IStrongStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrongStarContext differentiates from other interfaces.
	IsStrongStarContext()
}

type StrongStarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrongStarContext() *StrongStarContext {
	var p = new(StrongStarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_strongStar
	return p
}

func (*StrongStarContext) IsStrongStarContext() {}

func NewStrongStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrongStarContext {
	var p = new(StrongStarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_strongStar

	return p
}

func (s *StrongStarContext) GetParser() antlr.Parser { return s.parser }

func (s *StrongStarContext) AllEMPH() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserEMPH)
}

func (s *StrongStarContext) EMPH(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserEMPH, i)
}

func (s *StrongStarContext) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *StrongStarContext) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *StrongStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrongStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StrongStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterStrongStar(s)
	}
}

func (s *StrongStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitStrongStar(s)
	}
}




func (p *MarkdownParser) StrongStar() (localctx IStrongStarContext) {
	localctx = NewStrongStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MarkdownParserRULE_strongStar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(698)

	if !(!tokenStartsWith(3, " ")) {
		panic(antlr.NewFailedPredicateException(p, "!tokenStartsWith(3, \" \")", ""))
	}
	{
		p.SetState(699)
		p.Match(MarkdownParserEMPH)
	}
	{
		p.SetState(700)
		p.Match(MarkdownParserEMPH)
	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	_alt = 1+1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1+1:
				{
					p.SetState(701)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(704)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
	}
	{
		p.SetState(706)
		p.Match(MarkdownParserEMPH)
	}
	{
		p.SetState(707)
		p.Match(MarkdownParserEMPH)
	}



	return localctx
}


// IStrongUlContext is an interface to support dynamic dispatch.
type IStrongUlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrongUlContext differentiates from other interfaces.
	IsStrongUlContext()
}

type StrongUlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrongUlContext() *StrongUlContext {
	var p = new(StrongUlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_strongUl
	return p
}

func (*StrongUlContext) IsStrongUlContext() {}

func NewStrongUlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrongUlContext {
	var p = new(StrongUlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_strongUl

	return p
}

func (s *StrongUlContext) GetParser() antlr.Parser { return s.parser }

func (s *StrongUlContext) AllUNDERSCORE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserUNDERSCORE)
}

func (s *StrongUlContext) UNDERSCORE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserUNDERSCORE, i)
}

func (s *StrongUlContext) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *StrongUlContext) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *StrongUlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrongUlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StrongUlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterStrongUl(s)
	}
}

func (s *StrongUlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitStrongUl(s)
	}
}




func (p *MarkdownParser) StrongUl() (localctx IStrongUlContext) {
	localctx = NewStrongUlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MarkdownParserRULE_strongUl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(709)

	if !(!tokenStartsWith(3, " ")) {
		panic(antlr.NewFailedPredicateException(p, "!tokenStartsWith(3, \" \")", ""))
	}
	{
		p.SetState(710)
		p.Match(MarkdownParserUNDERSCORE)
	}
	{
		p.SetState(711)
		p.Match(MarkdownParserUNDERSCORE)
	}
	p.SetState(713)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(712)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())
	}
	{
		p.SetState(717)
		p.Match(MarkdownParserUNDERSCORE)
	}
	{
		p.SetState(718)
		p.Match(MarkdownParserUNDERSCORE)
	}



	return localctx
}


// IImageContext is an interface to support dynamic dispatch.
type IImageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImageContext differentiates from other interfaces.
	IsImageContext()
}

type ImageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImageContext() *ImageContext {
	var p = new(ImageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_image
	return p
}

func (*ImageContext) IsImageContext() {}

func NewImageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImageContext {
	var p = new(ImageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_image

	return p
}

func (s *ImageContext) GetParser() antlr.Parser { return s.parser }

func (s *ImageContext) EXCLAMATION_MARK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserEXCLAMATION_MARK, 0)
}

func (s *ImageContext) ImageLink() IImageLinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImageLinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImageLinkContext)
}

func (s *ImageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ImageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterImage(s)
	}
}

func (s *ImageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitImage(s)
	}
}




func (p *MarkdownParser) Image() (localctx IImageContext) {
	localctx = NewImageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MarkdownParserRULE_image)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.Match(MarkdownParserEXCLAMATION_MARK)
	}
	{
		p.SetState(721)
		p.ImageLink()
	}



	return localctx
}


// IImageLinkContext is an interface to support dynamic dispatch.
type IImageLinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImageLinkContext differentiates from other interfaces.
	IsImageLinkContext()
}

type ImageLinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImageLinkContext() *ImageLinkContext {
	var p = new(ImageLinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_imageLink
	return p
}

func (*ImageLinkContext) IsImageLinkContext() {}

func NewImageLinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImageLinkContext {
	var p = new(ImageLinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_imageLink

	return p
}

func (s *ImageLinkContext) GetParser() antlr.Parser { return s.parser }

func (s *ImageLinkContext) ImageAlt() IImageAltContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImageAltContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImageAltContext)
}

func (s *ImageLinkContext) ExplicitImageLink() IExplicitImageLinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitImageLinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitImageLinkContext)
}

func (s *ImageLinkContext) ReferenceImageLink() IReferenceImageLinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceImageLinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceImageLinkContext)
}

func (s *ImageLinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImageLinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ImageLinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterImageLink(s)
	}
}

func (s *ImageLinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitImageLink(s)
	}
}




func (p *MarkdownParser) ImageLink() (localctx IImageLinkContext) {
	localctx = NewImageLinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MarkdownParserRULE_imageLink)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(723)
		p.ImageAlt()
	}
	p.SetState(726)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MarkdownParserOPEN_PAREN:
		{
			p.SetState(724)
			p.ExplicitImageLink()
		}


	case MarkdownParserOPEN_SB:
		{
			p.SetState(725)
			p.ReferenceImageLink()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IExplicitImageLinkContext is an interface to support dynamic dispatch.
type IExplicitImageLinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitImageLinkContext differentiates from other interfaces.
	IsExplicitImageLinkContext()
}

type ExplicitImageLinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitImageLinkContext() *ExplicitImageLinkContext {
	var p = new(ExplicitImageLinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_explicitImageLink
	return p
}

func (*ExplicitImageLinkContext) IsExplicitImageLinkContext() {}

func NewExplicitImageLinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitImageLinkContext {
	var p = new(ExplicitImageLinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_explicitImageLink

	return p
}

func (s *ExplicitImageLinkContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitImageLinkContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_PAREN, 0)
}

func (s *ExplicitImageLinkContext) LinkUrl() ILinkUrlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkUrlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkUrlContext)
}

func (s *ExplicitImageLinkContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_PAREN, 0)
}

func (s *ExplicitImageLinkContext) LinkTitle() ILinkTitleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkTitleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkTitleContext)
}

func (s *ExplicitImageLinkContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *ExplicitImageLinkContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *ExplicitImageLinkContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *ExplicitImageLinkContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *ExplicitImageLinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitImageLinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExplicitImageLinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterExplicitImageLink(s)
	}
}

func (s *ExplicitImageLinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitExplicitImageLink(s)
	}
}




func (p *MarkdownParser) ExplicitImageLink() (localctx IExplicitImageLinkContext) {
	localctx = NewExplicitImageLinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MarkdownParserRULE_explicitImageLink)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(MarkdownParserOPEN_PAREN)
	}
	{
		p.SetState(729)
		p.LinkUrl()
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		p.SetState(731)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
			{
				p.SetState(730)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


			p.SetState(733)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(735)
			p.LinkTitle()
		}

	}
	{
		p.SetState(738)
		p.Match(MarkdownParserCLOSE_PAREN)
	}



	return localctx
}


// IImageAltContext is an interface to support dynamic dispatch.
type IImageAltContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImageAltContext differentiates from other interfaces.
	IsImageAltContext()
}

type ImageAltContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImageAltContext() *ImageAltContext {
	var p = new(ImageAltContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_imageAlt
	return p
}

func (*ImageAltContext) IsImageAltContext() {}

func NewImageAltContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImageAltContext {
	var p = new(ImageAltContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_imageAlt

	return p
}

func (s *ImageAltContext) GetParser() antlr.Parser { return s.parser }

func (s *ImageAltContext) OPEN_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_SB, 0)
}

func (s *ImageAltContext) AllCLOSE_SB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserCLOSE_SB)
}

func (s *ImageAltContext) CLOSE_SB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_SB, i)
}

func (s *ImageAltContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *ImageAltContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *ImageAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImageAltContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ImageAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterImageAlt(s)
	}
}

func (s *ImageAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitImageAlt(s)
	}
}




func (p *MarkdownParser) ImageAlt() (localctx IImageAltContext) {
	localctx = NewImageAltContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MarkdownParserRULE_imageAlt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(MarkdownParserOPEN_SB)
	}
	p.SetState(744)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(741)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MarkdownParserCLOSE_SB || _la == MarkdownParserNEWLINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(747)
		p.Match(MarkdownParserCLOSE_SB)
	}



	return localctx
}


// IReferenceImageLinkContext is an interface to support dynamic dispatch.
type IReferenceImageLinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceImageLinkContext differentiates from other interfaces.
	IsReferenceImageLinkContext()
}

type ReferenceImageLinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceImageLinkContext() *ReferenceImageLinkContext {
	var p = new(ReferenceImageLinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_referenceImageLink
	return p
}

func (*ReferenceImageLinkContext) IsReferenceImageLinkContext() {}

func NewReferenceImageLinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceImageLinkContext {
	var p = new(ReferenceImageLinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_referenceImageLink

	return p
}

func (s *ReferenceImageLinkContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceImageLinkContext) OPEN_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_SB, 0)
}

func (s *ReferenceImageLinkContext) ReferenceId() IReferenceIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceIdContext)
}

func (s *ReferenceImageLinkContext) CLOSE_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_SB, 0)
}

func (s *ReferenceImageLinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceImageLinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceImageLinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferenceImageLink(s)
	}
}

func (s *ReferenceImageLinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferenceImageLink(s)
	}
}




func (p *MarkdownParser) ReferenceImageLink() (localctx IReferenceImageLinkContext) {
	localctx = NewReferenceImageLinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MarkdownParserRULE_referenceImageLink)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.Match(MarkdownParserOPEN_SB)
	}
	{
		p.SetState(750)
		p.ReferenceId()
	}
	{
		p.SetState(751)
		p.Match(MarkdownParserCLOSE_SB)
	}



	return localctx
}


// ILinkContext is an interface to support dynamic dispatch.
type ILinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkContext differentiates from other interfaces.
	IsLinkContext()
}

type LinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkContext() *LinkContext {
	var p = new(LinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_link
	return p
}

func (*LinkContext) IsLinkContext() {}

func NewLinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkContext {
	var p = new(LinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_link

	return p
}

func (s *LinkContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkContext) LinkContent() ILinkContentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkContentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkContentContext)
}

func (s *LinkContext) ExplicitLink() IExplicitLinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitLinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitLinkContext)
}

func (s *LinkContext) ReferenceLink() IReferenceLinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceLinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceLinkContext)
}

func (s *LinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterLink(s)
	}
}

func (s *LinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitLink(s)
	}
}




func (p *MarkdownParser) Link() (localctx ILinkContext) {
	localctx = NewLinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MarkdownParserRULE_link)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(753)
		p.LinkContent()
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(754)
			p.ExplicitLink()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(755)
			p.ReferenceLink()
		}


	}



	return localctx
}


// ILinkContentContext is an interface to support dynamic dispatch.
type ILinkContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkContentContext differentiates from other interfaces.
	IsLinkContentContext()
}

type LinkContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkContentContext() *LinkContentContext {
	var p = new(LinkContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_linkContent
	return p
}

func (*LinkContentContext) IsLinkContentContext() {}

func NewLinkContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkContentContext {
	var p = new(LinkContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_linkContent

	return p
}

func (s *LinkContentContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkContentContext) OPEN_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_SB, 0)
}

func (s *LinkContentContext) CLOSE_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_SB, 0)
}

func (s *LinkContentContext) AllInline() []IInlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineContext)(nil)).Elem())
	var tst = make([]IInlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineContext)
		}
	}

	return tst
}

func (s *LinkContentContext) Inline(i int) IInlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineContext)
}

func (s *LinkContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LinkContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterLinkContent(s)
	}
}

func (s *LinkContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitLinkContent(s)
	}
}




func (p *MarkdownParser) LinkContent() (localctx ILinkContentContext) {
	localctx = NewLinkContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MarkdownParserRULE_linkContent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.Match(MarkdownParserOPEN_SB)
	}
	p.SetState(760)
	p.GetErrorHandler().Sync(p)
	_alt = 1+1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1+1:
				{
					p.SetState(759)
					p.Inline()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext())
	}
	{
		p.SetState(764)
		p.Match(MarkdownParserCLOSE_SB)
	}



	return localctx
}


// IExplicitLinkContext is an interface to support dynamic dispatch.
type IExplicitLinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitLinkContext differentiates from other interfaces.
	IsExplicitLinkContext()
}

type ExplicitLinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitLinkContext() *ExplicitLinkContext {
	var p = new(ExplicitLinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_explicitLink
	return p
}

func (*ExplicitLinkContext) IsExplicitLinkContext() {}

func NewExplicitLinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitLinkContext {
	var p = new(ExplicitLinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_explicitLink

	return p
}

func (s *ExplicitLinkContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitLinkContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_PAREN, 0)
}

func (s *ExplicitLinkContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_PAREN, 0)
}

func (s *ExplicitLinkContext) LinkUrl() ILinkUrlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkUrlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkUrlContext)
}

func (s *ExplicitLinkContext) LinkTitle() ILinkTitleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkTitleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkTitleContext)
}

func (s *ExplicitLinkContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *ExplicitLinkContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *ExplicitLinkContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *ExplicitLinkContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *ExplicitLinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitLinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExplicitLinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterExplicitLink(s)
	}
}

func (s *ExplicitLinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitExplicitLink(s)
	}
}




func (p *MarkdownParser) ExplicitLink() (localctx IExplicitLinkContext) {
	localctx = NewExplicitLinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MarkdownParserRULE_explicitLink)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(MarkdownParserOPEN_PAREN)
	}
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(767)
			p.LinkUrl()
		}

	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
			{
				p.SetState(770)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


			p.SetState(773)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(775)
			p.LinkTitle()
		}


	}
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(778)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(784)
		p.Match(MarkdownParserCLOSE_PAREN)
	}



	return localctx
}


// ILinkUrlContext is an interface to support dynamic dispatch.
type ILinkUrlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkUrlContext differentiates from other interfaces.
	IsLinkUrlContext()
}

type LinkUrlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkUrlContext() *LinkUrlContext {
	var p = new(LinkUrlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_linkUrl
	return p
}

func (*LinkUrlContext) IsLinkUrlContext() {}

func NewLinkUrlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkUrlContext {
	var p = new(LinkUrlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_linkUrl

	return p
}

func (s *LinkUrlContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkUrlContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *LinkUrlContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *LinkUrlContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *LinkUrlContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *LinkUrlContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *LinkUrlContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *LinkUrlContext) AllCLOSE_PAREN() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserCLOSE_PAREN)
}

func (s *LinkUrlContext) CLOSE_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_PAREN, i)
}

func (s *LinkUrlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkUrlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LinkUrlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterLinkUrl(s)
	}
}

func (s *LinkUrlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitLinkUrl(s)
	}
}




func (p *MarkdownParser) LinkUrl() (localctx ILinkUrlContext) {
	localctx = NewLinkUrlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MarkdownParserRULE_linkUrl)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(786)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserCLOSE_PAREN))) != 0) || _la == MarkdownParserNEWLINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ILinkTitleContext is an interface to support dynamic dispatch.
type ILinkTitleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkTitleContext differentiates from other interfaces.
	IsLinkTitleContext()
}

type LinkTitleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkTitleContext() *LinkTitleContext {
	var p = new(LinkTitleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_linkTitle
	return p
}

func (*LinkTitleContext) IsLinkTitleContext() {}

func NewLinkTitleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkTitleContext {
	var p = new(LinkTitleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_linkTitle

	return p
}

func (s *LinkTitleContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkTitleContext) LinkTitleSingle() ILinkTitleSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkTitleSingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkTitleSingleContext)
}

func (s *LinkTitleContext) LinkTitleDouble() ILinkTitleDoubleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkTitleDoubleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkTitleDoubleContext)
}

func (s *LinkTitleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkTitleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LinkTitleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterLinkTitle(s)
	}
}

func (s *LinkTitleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitLinkTitle(s)
	}
}




func (p *MarkdownParser) LinkTitle() (localctx ILinkTitleContext) {
	localctx = NewLinkTitleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MarkdownParserRULE_linkTitle)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(793)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MarkdownParserSINGLE_QUOTE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(791)
			p.LinkTitleSingle()
		}


	case MarkdownParserDOUBLE_QUOTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(792)
			p.LinkTitleDouble()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ILinkTitleSingleContext is an interface to support dynamic dispatch.
type ILinkTitleSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkTitleSingleContext differentiates from other interfaces.
	IsLinkTitleSingleContext()
}

type LinkTitleSingleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkTitleSingleContext() *LinkTitleSingleContext {
	var p = new(LinkTitleSingleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_linkTitleSingle
	return p
}

func (*LinkTitleSingleContext) IsLinkTitleSingleContext() {}

func NewLinkTitleSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkTitleSingleContext {
	var p = new(LinkTitleSingleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_linkTitleSingle

	return p
}

func (s *LinkTitleSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkTitleSingleContext) AllSINGLE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSINGLE_QUOTE)
}

func (s *LinkTitleSingleContext) SINGLE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSINGLE_QUOTE, i)
}

func (s *LinkTitleSingleContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *LinkTitleSingleContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *LinkTitleSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkTitleSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LinkTitleSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterLinkTitleSingle(s)
	}
}

func (s *LinkTitleSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitLinkTitleSingle(s)
	}
}




func (p *MarkdownParser) LinkTitleSingle() (localctx ILinkTitleSingleContext) {
	localctx = NewLinkTitleSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MarkdownParserRULE_linkTitleSingle)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		p.Match(MarkdownParserSINGLE_QUOTE)
	}
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(796)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MarkdownParserSINGLE_QUOTE || _la == MarkdownParserNEWLINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(802)
		p.Match(MarkdownParserSINGLE_QUOTE)
	}



	return localctx
}


// ILinkTitleDoubleContext is an interface to support dynamic dispatch.
type ILinkTitleDoubleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkTitleDoubleContext differentiates from other interfaces.
	IsLinkTitleDoubleContext()
}

type LinkTitleDoubleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkTitleDoubleContext() *LinkTitleDoubleContext {
	var p = new(LinkTitleDoubleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_linkTitleDouble
	return p
}

func (*LinkTitleDoubleContext) IsLinkTitleDoubleContext() {}

func NewLinkTitleDoubleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkTitleDoubleContext {
	var p = new(LinkTitleDoubleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_linkTitleDouble

	return p
}

func (s *LinkTitleDoubleContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkTitleDoubleContext) AllDOUBLE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserDOUBLE_QUOTE)
}

func (s *LinkTitleDoubleContext) DOUBLE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserDOUBLE_QUOTE, i)
}

func (s *LinkTitleDoubleContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNEWLINE)
}

func (s *LinkTitleDoubleContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, i)
}

func (s *LinkTitleDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkTitleDoubleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LinkTitleDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterLinkTitleDouble(s)
	}
}

func (s *LinkTitleDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitLinkTitleDouble(s)
	}
}




func (p *MarkdownParser) LinkTitleDouble() (localctx ILinkTitleDoubleContext) {
	localctx = NewLinkTitleDoubleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MarkdownParserRULE_linkTitleDouble)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		p.Match(MarkdownParserDOUBLE_QUOTE)
	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(805)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MarkdownParserDOUBLE_QUOTE || _la == MarkdownParserNEWLINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(811)
		p.Match(MarkdownParserDOUBLE_QUOTE)
	}



	return localctx
}


// IReferenceLinkContext is an interface to support dynamic dispatch.
type IReferenceLinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceLinkContext differentiates from other interfaces.
	IsReferenceLinkContext()
}

type ReferenceLinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceLinkContext() *ReferenceLinkContext {
	var p = new(ReferenceLinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_referenceLink
	return p
}

func (*ReferenceLinkContext) IsReferenceLinkContext() {}

func NewReferenceLinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceLinkContext {
	var p = new(ReferenceLinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_referenceLink

	return p
}

func (s *ReferenceLinkContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceLinkContext) OPEN_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_SB, 0)
}

func (s *ReferenceLinkContext) CLOSE_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_SB, 0)
}

func (s *ReferenceLinkContext) ReferenceId() IReferenceIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceIdContext)
}

func (s *ReferenceLinkContext) SPACE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, 0)
}

func (s *ReferenceLinkContext) TAB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, 0)
}

func (s *ReferenceLinkContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *ReferenceLinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceLinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceLinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterReferenceLink(s)
	}
}

func (s *ReferenceLinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitReferenceLink(s)
	}
}




func (p *MarkdownParser) ReferenceLink() (localctx IReferenceLinkContext) {
	localctx = NewReferenceLinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MarkdownParserRULE_referenceLink)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == MarkdownParserSPACE || _la == MarkdownParserTAB || _la == MarkdownParserNEWLINE {
		{
			p.SetState(813)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB || _la == MarkdownParserNEWLINE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(816)
		p.Match(MarkdownParserOPEN_SB)
	}
	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserBLANK_LINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(817)
			p.ReferenceId()
		}

	}
	{
		p.SetState(820)
		p.Match(MarkdownParserCLOSE_SB)
	}



	return localctx
}


// IEntityContext is an interface to support dynamic dispatch.
type IEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntityContext differentiates from other interfaces.
	IsEntityContext()
}

type EntityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntityContext() *EntityContext {
	var p = new(EntityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_entity
	return p
}

func (*EntityContext) IsEntityContext() {}

func NewEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntityContext {
	var p = new(EntityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_entity

	return p
}

func (s *EntityContext) GetParser() antlr.Parser { return s.parser }

func (s *EntityContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(MarkdownParserAMPERSAND, 0)
}

func (s *EntityContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSEMI_COLON, 0)
}

func (s *EntityContext) SHARP() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSHARP, 0)
}

func (s *EntityContext) HexEntityName() IHexEntityNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHexEntityNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHexEntityNameContext)
}

func (s *EntityContext) DecEntityName() IDecEntityNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecEntityNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecEntityNameContext)
}

func (s *EntityContext) CharEntityName() ICharEntityNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharEntityNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharEntityNameContext)
}

func (s *EntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EntityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterEntity(s)
	}
}

func (s *EntityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitEntity(s)
	}
}




func (p *MarkdownParser) Entity() (localctx IEntityContext) {
	localctx = NewEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MarkdownParserRULE_entity)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(822)
		p.Match(MarkdownParserAMPERSAND)
	}
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(823)
			p.Match(MarkdownParserSHARP)
		}
		{
			p.SetState(824)
			p.HexEntityName()
		}


	case 2:
		{
			p.SetState(825)
			p.Match(MarkdownParserSHARP)
		}
		{
			p.SetState(826)
			p.DecEntityName()
		}


	case 3:
		{
			p.SetState(827)
			p.CharEntityName()
		}

	}
	{
		p.SetState(830)
		p.Match(MarkdownParserSEMI_COLON)
	}



	return localctx
}


// IHexEntityNameContext is an interface to support dynamic dispatch.
type IHexEntityNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexEntityNameContext differentiates from other interfaces.
	IsHexEntityNameContext()
}

type HexEntityNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexEntityNameContext() *HexEntityNameContext {
	var p = new(HexEntityNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_hexEntityName
	return p
}

func (*HexEntityNameContext) IsHexEntityNameContext() {}

func NewHexEntityNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexEntityNameContext {
	var p = new(HexEntityNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_hexEntityName

	return p
}

func (s *HexEntityNameContext) GetParser() antlr.Parser { return s.parser }

func (s *HexEntityNameContext) AllHEX_CHAR() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserHEX_CHAR)
}

func (s *HexEntityNameContext) HEX_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserHEX_CHAR, i)
}

func (s *HexEntityNameContext) AllD() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserD)
}

func (s *HexEntityNameContext) D(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserD, i)
}

func (s *HexEntityNameContext) AllA() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserA)
}

func (s *HexEntityNameContext) A(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserA, i)
}

func (s *HexEntityNameContext) AllDIGIT() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserDIGIT)
}

func (s *HexEntityNameContext) DIGIT(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserDIGIT, i)
}

func (s *HexEntityNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexEntityNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HexEntityNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHexEntityName(s)
	}
}

func (s *HexEntityNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHexEntityName(s)
	}
}




func (p *MarkdownParser) HexEntityName() (localctx IHexEntityNameContext) {
	localctx = NewHexEntityNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MarkdownParserRULE_hexEntityName)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = ((((_la - 27)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 27))) & ((1 << (MarkdownParserD - 27)) | (1 << (MarkdownParserA - 27)) | (1 << (MarkdownParserHEX_CHAR - 27)) | (1 << (MarkdownParserDIGIT - 27)))) != 0) {
		{
			p.SetState(832)
			_la = p.GetTokenStream().LA(1)

			if !(((((_la - 27)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 27))) & ((1 << (MarkdownParserD - 27)) | (1 << (MarkdownParserA - 27)) | (1 << (MarkdownParserHEX_CHAR - 27)) | (1 << (MarkdownParserDIGIT - 27)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IDecEntityNameContext is an interface to support dynamic dispatch.
type IDecEntityNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecEntityNameContext differentiates from other interfaces.
	IsDecEntityNameContext()
}

type DecEntityNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecEntityNameContext() *DecEntityNameContext {
	var p = new(DecEntityNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_decEntityName
	return p
}

func (*DecEntityNameContext) IsDecEntityNameContext() {}

func NewDecEntityNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecEntityNameContext {
	var p = new(DecEntityNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_decEntityName

	return p
}

func (s *DecEntityNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DecEntityNameContext) AllDIGIT() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserDIGIT)
}

func (s *DecEntityNameContext) DIGIT(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserDIGIT, i)
}

func (s *DecEntityNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecEntityNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecEntityNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterDecEntityName(s)
	}
}

func (s *DecEntityNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitDecEntityName(s)
	}
}




func (p *MarkdownParser) DecEntityName() (localctx IDecEntityNameContext) {
	localctx = NewDecEntityNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MarkdownParserRULE_decEntityName)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == MarkdownParserDIGIT {
		{
			p.SetState(837)
			p.Match(MarkdownParserDIGIT)
		}


		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ICharEntityNameContext is an interface to support dynamic dispatch.
type ICharEntityNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharEntityNameContext differentiates from other interfaces.
	IsCharEntityNameContext()
}

type CharEntityNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharEntityNameContext() *CharEntityNameContext {
	var p = new(CharEntityNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_charEntityName
	return p
}

func (*CharEntityNameContext) IsCharEntityNameContext() {}

func NewCharEntityNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharEntityNameContext {
	var p = new(CharEntityNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_charEntityName

	return p
}

func (s *CharEntityNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharEntityNameContext) AllHEX_CHAR() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserHEX_CHAR)
}

func (s *CharEntityNameContext) HEX_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserHEX_CHAR, i)
}

func (s *CharEntityNameContext) AllNORMAL_CHAR() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNORMAL_CHAR)
}

func (s *CharEntityNameContext) NORMAL_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNORMAL_CHAR, i)
}

func (s *CharEntityNameContext) AllD() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserD)
}

func (s *CharEntityNameContext) D(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserD, i)
}

func (s *CharEntityNameContext) AllI() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserI)
}

func (s *CharEntityNameContext) I(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserI, i)
}

func (s *CharEntityNameContext) AllV() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserV)
}

func (s *CharEntityNameContext) V(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserV, i)
}

func (s *CharEntityNameContext) AllS() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserS)
}

func (s *CharEntityNameContext) S(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserS, i)
}

func (s *CharEntityNameContext) AllP() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserP)
}

func (s *CharEntityNameContext) P(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserP, i)
}

func (s *CharEntityNameContext) AllA() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserA)
}

func (s *CharEntityNameContext) A(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserA, i)
}

func (s *CharEntityNameContext) AllN() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserN)
}

func (s *CharEntityNameContext) N(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserN, i)
}

func (s *CharEntityNameContext) AllH() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserH)
}

func (s *CharEntityNameContext) H(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserH, i)
}

func (s *CharEntityNameContext) AllR() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserR)
}

func (s *CharEntityNameContext) R(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserR, i)
}

func (s *CharEntityNameContext) AllDIGIT() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserDIGIT)
}

func (s *CharEntityNameContext) DIGIT(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserDIGIT, i)
}

func (s *CharEntityNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharEntityNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CharEntityNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterCharEntityName(s)
	}
}

func (s *CharEntityNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitCharEntityName(s)
	}
}




func (p *MarkdownParser) CharEntityName() (localctx ICharEntityNameContext) {
	localctx = NewCharEntityNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MarkdownParserRULE_charEntityName)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = ((((_la - 27)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 27))) & ((1 << (MarkdownParserD - 27)) | (1 << (MarkdownParserI - 27)) | (1 << (MarkdownParserV - 27)) | (1 << (MarkdownParserS - 27)) | (1 << (MarkdownParserP - 27)) | (1 << (MarkdownParserA - 27)) | (1 << (MarkdownParserN - 27)) | (1 << (MarkdownParserH - 27)) | (1 << (MarkdownParserR - 27)) | (1 << (MarkdownParserHEX_CHAR - 27)) | (1 << (MarkdownParserNORMAL_CHAR - 27)) | (1 << (MarkdownParserDIGIT - 27)))) != 0) {
		{
			p.SetState(842)
			_la = p.GetTokenStream().LA(1)

			if !(((((_la - 27)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 27))) & ((1 << (MarkdownParserD - 27)) | (1 << (MarkdownParserI - 27)) | (1 << (MarkdownParserV - 27)) | (1 << (MarkdownParserS - 27)) | (1 << (MarkdownParserP - 27)) | (1 << (MarkdownParserA - 27)) | (1 << (MarkdownParserN - 27)) | (1 << (MarkdownParserH - 27)) | (1 << (MarkdownParserR - 27)) | (1 << (MarkdownParserHEX_CHAR - 27)) | (1 << (MarkdownParserNORMAL_CHAR - 27)) | (1 << (MarkdownParserDIGIT - 27)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(845)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IEscapedCharContext is an interface to support dynamic dispatch.
type IEscapedCharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscapedCharContext differentiates from other interfaces.
	IsEscapedCharContext()
}

type EscapedCharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscapedCharContext() *EscapedCharContext {
	var p = new(EscapedCharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_escapedChar
	return p
}

func (*EscapedCharContext) IsEscapedCharContext() {}

func NewEscapedCharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EscapedCharContext {
	var p = new(EscapedCharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_escapedChar

	return p
}

func (s *EscapedCharContext) GetParser() antlr.Parser { return s.parser }

func (s *EscapedCharContext) AllBACKSLASH() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBACKSLASH)
}

func (s *EscapedCharContext) BACKSLASH(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBACKSLASH, i)
}

func (s *EscapedCharContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MarkdownParserMINUS, 0)
}

func (s *EscapedCharContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(MarkdownParserPERIOD, 0)
}

func (s *EscapedCharContext) BACKTICK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserBACKTICK, 0)
}

func (s *EscapedCharContext) EMPH() antlr.TerminalNode {
	return s.GetToken(MarkdownParserEMPH, 0)
}

func (s *EscapedCharContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserUNDERSCORE, 0)
}

func (s *EscapedCharContext) EXCLAMATION_MARK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserEXCLAMATION_MARK, 0)
}

func (s *EscapedCharContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MarkdownParserPLUS, 0)
}

func (s *EscapedCharContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_PAREN, 0)
}

func (s *EscapedCharContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_PAREN, 0)
}

func (s *EscapedCharContext) SHARP() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSHARP, 0)
}

func (s *EscapedCharContext) OPEN_CURLY() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_CURLY, 0)
}

func (s *EscapedCharContext) CLOSE_CURLY() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_CURLY, 0)
}

func (s *EscapedCharContext) OPEN_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_SB, 0)
}

func (s *EscapedCharContext) CLOSE_SB() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_SB, 0)
}

func (s *EscapedCharContext) OPEN_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, 0)
}

func (s *EscapedCharContext) CLOSE_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, 0)
}

func (s *EscapedCharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EscapedCharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EscapedCharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterEscapedChar(s)
	}
}

func (s *EscapedCharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitEscapedChar(s)
	}
}




func (p *MarkdownParser) EscapedChar() (localctx IEscapedCharContext) {
	localctx = NewEscapedCharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MarkdownParserRULE_escapedChar)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(847)
		p.Match(MarkdownParserBACKSLASH)
	}
	{
		p.SetState(848)
		_la = p.GetTokenStream().LA(1)

		if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserCLOSE_ANGLE_BRACKET) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY))) != 0) || _la == MarkdownParserSHARP || _la == MarkdownParserOPEN_ANGLE_BRACKET) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// ICodeContext is an interface to support dynamic dispatch.
type ICodeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodeContext differentiates from other interfaces.
	IsCodeContext()
}

type CodeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeContext() *CodeContext {
	var p = new(CodeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_code
	return p
}

func (*CodeContext) IsCodeContext() {}

func NewCodeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeContext {
	var p = new(CodeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_code

	return p
}

func (s *CodeContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeContext) SpaceBacktickCode() ISpaceBacktickCodeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpaceBacktickCodeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpaceBacktickCodeContext)
}

func (s *CodeContext) DoubleBacktickCode() IDoubleBacktickCodeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoubleBacktickCodeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoubleBacktickCodeContext)
}

func (s *CodeContext) BacktickCode() IBacktickCodeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBacktickCodeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBacktickCodeContext)
}

func (s *CodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterCode(s)
	}
}

func (s *CodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitCode(s)
	}
}




func (p *MarkdownParser) Code() (localctx ICodeContext) {
	localctx = NewCodeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MarkdownParserRULE_code)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(853)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(850)
			p.SpaceBacktickCode()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(851)
			p.DoubleBacktickCode()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(852)
			p.BacktickCode()
		}

	}


	return localctx
}


// IBacktickCodeContext is an interface to support dynamic dispatch.
type IBacktickCodeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBacktickCodeContext differentiates from other interfaces.
	IsBacktickCodeContext()
}

type BacktickCodeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBacktickCodeContext() *BacktickCodeContext {
	var p = new(BacktickCodeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_backtickCode
	return p
}

func (*BacktickCodeContext) IsBacktickCodeContext() {}

func NewBacktickCodeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BacktickCodeContext {
	var p = new(BacktickCodeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_backtickCode

	return p
}

func (s *BacktickCodeContext) GetParser() antlr.Parser { return s.parser }

func (s *BacktickCodeContext) AllBACKTICK() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBACKTICK)
}

func (s *BacktickCodeContext) BACKTICK(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBACKTICK, i)
}

func (s *BacktickCodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BacktickCodeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BacktickCodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterBacktickCode(s)
	}
}

func (s *BacktickCodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitBacktickCode(s)
	}
}




func (p *MarkdownParser) BacktickCode() (localctx IBacktickCodeContext) {
	localctx = NewBacktickCodeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MarkdownParserRULE_backtickCode)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(855)

	if !(!tokenIs(2, BACKTICK)) {
		panic(antlr.NewFailedPredicateException(p, "!tokenIs(2, BACKTICK)", ""))
	}
	{
		p.SetState(856)
		p.Match(MarkdownParserBACKTICK)
	}
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	_alt = 1+1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1+1:
				p.SetState(857)

				if !(!tokenIs(1, BLANK_LINE)) {
					panic(antlr.NewFailedPredicateException(p, "!tokenIs(1, BLANK_LINE)", ""))
				}
				p.SetState(858)
				p.MatchWildcard()





		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(861)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
	}
	{
		p.SetState(863)
		p.Match(MarkdownParserBACKTICK)
	}



	return localctx
}


// IDoubleBacktickCodeContext is an interface to support dynamic dispatch.
type IDoubleBacktickCodeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoubleBacktickCodeContext differentiates from other interfaces.
	IsDoubleBacktickCodeContext()
}

type DoubleBacktickCodeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoubleBacktickCodeContext() *DoubleBacktickCodeContext {
	var p = new(DoubleBacktickCodeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_doubleBacktickCode
	return p
}

func (*DoubleBacktickCodeContext) IsDoubleBacktickCodeContext() {}

func NewDoubleBacktickCodeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleBacktickCodeContext {
	var p = new(DoubleBacktickCodeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_doubleBacktickCode

	return p
}

func (s *DoubleBacktickCodeContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleBacktickCodeContext) AllBACKTICK() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBACKTICK)
}

func (s *DoubleBacktickCodeContext) BACKTICK(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBACKTICK, i)
}

func (s *DoubleBacktickCodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleBacktickCodeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DoubleBacktickCodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterDoubleBacktickCode(s)
	}
}

func (s *DoubleBacktickCodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitDoubleBacktickCode(s)
	}
}




func (p *MarkdownParser) DoubleBacktickCode() (localctx IDoubleBacktickCodeContext) {
	localctx = NewDoubleBacktickCodeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MarkdownParserRULE_doubleBacktickCode)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(865)

	if !(!tokenIs(3, SPACE) && !tokenIs(3, TAB)) {
		panic(antlr.NewFailedPredicateException(p, "!tokenIs(3, SPACE) && !tokenIs(3, TAB)", ""))
	}
	{
		p.SetState(866)
		p.Match(MarkdownParserBACKTICK)
	}
	{
		p.SetState(867)
		p.Match(MarkdownParserBACKTICK)
	}
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	_alt = 1+1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1+1:
				p.SetState(868)

				if !(!tokenIs(1, BLANK_LINE)) {
					panic(antlr.NewFailedPredicateException(p, "!tokenIs(1, BLANK_LINE)", ""))
				}
				p.SetState(869)
				p.MatchWildcard()





		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())
	}
	{
		p.SetState(874)
		p.Match(MarkdownParserBACKTICK)
	}
	{
		p.SetState(875)
		p.Match(MarkdownParserBACKTICK)
	}



	return localctx
}


// ISpaceBacktickCodeContext is an interface to support dynamic dispatch.
type ISpaceBacktickCodeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpaceBacktickCodeContext differentiates from other interfaces.
	IsSpaceBacktickCodeContext()
}

type SpaceBacktickCodeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpaceBacktickCodeContext() *SpaceBacktickCodeContext {
	var p = new(SpaceBacktickCodeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_spaceBacktickCode
	return p
}

func (*SpaceBacktickCodeContext) IsSpaceBacktickCodeContext() {}

func NewSpaceBacktickCodeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpaceBacktickCodeContext {
	var p = new(SpaceBacktickCodeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_spaceBacktickCode

	return p
}

func (s *SpaceBacktickCodeContext) GetParser() antlr.Parser { return s.parser }

func (s *SpaceBacktickCodeContext) AllBACKTICK() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBACKTICK)
}

func (s *SpaceBacktickCodeContext) BACKTICK(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBACKTICK, i)
}

func (s *SpaceBacktickCodeContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *SpaceBacktickCodeContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *SpaceBacktickCodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpaceBacktickCodeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SpaceBacktickCodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterSpaceBacktickCode(s)
	}
}

func (s *SpaceBacktickCodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitSpaceBacktickCode(s)
	}
}




func (p *MarkdownParser) SpaceBacktickCode() (localctx ISpaceBacktickCodeContext) {
	localctx = NewSpaceBacktickCodeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MarkdownParserRULE_spaceBacktickCode)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.Match(MarkdownParserBACKTICK)
	}
	{
		p.SetState(878)
		p.Match(MarkdownParserBACKTICK)
	}
	{
		p.SetState(879)
		p.Match(MarkdownParserSPACE)
	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	_alt = 1+1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1+1:
				p.SetState(880)

				if !(!tokenIs(1, BLANK_LINE)) {
					panic(antlr.NewFailedPredicateException(p, "!tokenIs(1, BLANK_LINE)", ""))
				}
				p.SetState(881)
				p.MatchWildcard()





		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext())
	}
	{
		p.SetState(886)
		p.Match(MarkdownParserSPACE)
	}
	{
		p.SetState(887)
		p.Match(MarkdownParserBACKTICK)
	}
	{
		p.SetState(888)
		p.Match(MarkdownParserBACKTICK)
	}



	return localctx
}


// IAttributeNameContext is an interface to support dynamic dispatch.
type IAttributeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeNameContext differentiates from other interfaces.
	IsAttributeNameContext()
}

type AttributeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameContext() *AttributeNameContext {
	var p = new(AttributeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_attributeName
	return p
}

func (*AttributeNameContext) IsAttributeNameContext() {}

func NewAttributeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameContext {
	var p = new(AttributeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_attributeName

	return p
}

func (s *AttributeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNameContext) AllNORMAL_CHAR() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserNORMAL_CHAR)
}

func (s *AttributeNameContext) NORMAL_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserNORMAL_CHAR, i)
}

func (s *AttributeNameContext) AllHEX_CHAR() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserHEX_CHAR)
}

func (s *AttributeNameContext) HEX_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserHEX_CHAR, i)
}

func (s *AttributeNameContext) AllD() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserD)
}

func (s *AttributeNameContext) D(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserD, i)
}

func (s *AttributeNameContext) AllI() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserI)
}

func (s *AttributeNameContext) I(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserI, i)
}

func (s *AttributeNameContext) AllV() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserV)
}

func (s *AttributeNameContext) V(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserV, i)
}

func (s *AttributeNameContext) AllS() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserS)
}

func (s *AttributeNameContext) S(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserS, i)
}

func (s *AttributeNameContext) AllP() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserP)
}

func (s *AttributeNameContext) P(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserP, i)
}

func (s *AttributeNameContext) AllA() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserA)
}

func (s *AttributeNameContext) A(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserA, i)
}

func (s *AttributeNameContext) AllN() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserN)
}

func (s *AttributeNameContext) N(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserN, i)
}

func (s *AttributeNameContext) AllH() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserH)
}

func (s *AttributeNameContext) H(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserH, i)
}

func (s *AttributeNameContext) AllR() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserR)
}

func (s *AttributeNameContext) R(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserR, i)
}

func (s *AttributeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AttributeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterAttributeName(s)
	}
}

func (s *AttributeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitAttributeName(s)
	}
}




func (p *MarkdownParser) AttributeName() (localctx IAttributeNameContext) {
	localctx = NewAttributeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MarkdownParserRULE_attributeName)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = ((((_la - 27)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 27))) & ((1 << (MarkdownParserD - 27)) | (1 << (MarkdownParserI - 27)) | (1 << (MarkdownParserV - 27)) | (1 << (MarkdownParserS - 27)) | (1 << (MarkdownParserP - 27)) | (1 << (MarkdownParserA - 27)) | (1 << (MarkdownParserN - 27)) | (1 << (MarkdownParserH - 27)) | (1 << (MarkdownParserR - 27)) | (1 << (MarkdownParserHEX_CHAR - 27)) | (1 << (MarkdownParserNORMAL_CHAR - 27)))) != 0) {
		{
			p.SetState(890)
			_la = p.GetTokenStream().LA(1)

			if !(((((_la - 27)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 27))) & ((1 << (MarkdownParserD - 27)) | (1 << (MarkdownParserI - 27)) | (1 << (MarkdownParserV - 27)) | (1 << (MarkdownParserS - 27)) | (1 << (MarkdownParserP - 27)) | (1 << (MarkdownParserA - 27)) | (1 << (MarkdownParserN - 27)) | (1 << (MarkdownParserH - 27)) | (1 << (MarkdownParserR - 27)) | (1 << (MarkdownParserHEX_CHAR - 27)) | (1 << (MarkdownParserNORMAL_CHAR - 27)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(893)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IHtmlAttributeSContext is an interface to support dynamic dispatch.
type IHtmlAttributeSContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlAttributeSContext differentiates from other interfaces.
	IsHtmlAttributeSContext()
}

type HtmlAttributeSContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlAttributeSContext() *HtmlAttributeSContext {
	var p = new(HtmlAttributeSContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlAttributeS
	return p
}

func (*HtmlAttributeSContext) IsHtmlAttributeSContext() {}

func NewHtmlAttributeSContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlAttributeSContext {
	var p = new(HtmlAttributeSContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlAttributeS

	return p
}

func (s *HtmlAttributeSContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlAttributeSContext) AttributeName() IAttributeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *HtmlAttributeSContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(MarkdownParserEQUAL, 0)
}

func (s *HtmlAttributeSContext) AllSINGLE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSINGLE_QUOTE)
}

func (s *HtmlAttributeSContext) SINGLE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSINGLE_QUOTE, i)
}

func (s *HtmlAttributeSContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlAttributeSContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlAttributeSContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlAttributeS(s)
	}
}

func (s *HtmlAttributeSContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlAttributeS(s)
	}
}




func (p *MarkdownParser) HtmlAttributeS() (localctx IHtmlAttributeSContext) {
	localctx = NewHtmlAttributeSContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MarkdownParserRULE_htmlAttributeS)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.AttributeName()
	}
	{
		p.SetState(896)
		p.Match(MarkdownParserEQUAL)
	}
	{
		p.SetState(897)
		p.Match(MarkdownParserSINGLE_QUOTE)
	}
	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(898)
			p.MatchWildcard()



		}
		p.SetState(903)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())
	}
	{
		p.SetState(904)
		p.Match(MarkdownParserSINGLE_QUOTE)
	}



	return localctx
}


// IHtmlAttributeDContext is an interface to support dynamic dispatch.
type IHtmlAttributeDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlAttributeDContext differentiates from other interfaces.
	IsHtmlAttributeDContext()
}

type HtmlAttributeDContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlAttributeDContext() *HtmlAttributeDContext {
	var p = new(HtmlAttributeDContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlAttributeD
	return p
}

func (*HtmlAttributeDContext) IsHtmlAttributeDContext() {}

func NewHtmlAttributeDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlAttributeDContext {
	var p = new(HtmlAttributeDContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlAttributeD

	return p
}

func (s *HtmlAttributeDContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlAttributeDContext) AttributeName() IAttributeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *HtmlAttributeDContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(MarkdownParserEQUAL, 0)
}

func (s *HtmlAttributeDContext) AllDOUBLE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserDOUBLE_QUOTE)
}

func (s *HtmlAttributeDContext) DOUBLE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserDOUBLE_QUOTE, i)
}

func (s *HtmlAttributeDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlAttributeDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlAttributeDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlAttributeD(s)
	}
}

func (s *HtmlAttributeDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlAttributeD(s)
	}
}




func (p *MarkdownParser) HtmlAttributeD() (localctx IHtmlAttributeDContext) {
	localctx = NewHtmlAttributeDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MarkdownParserRULE_htmlAttributeD)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.AttributeName()
	}
	{
		p.SetState(907)
		p.Match(MarkdownParserEQUAL)
	}
	{
		p.SetState(908)
		p.Match(MarkdownParserDOUBLE_QUOTE)
	}
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(909)
			p.MatchWildcard()



		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())
	}
	{
		p.SetState(915)
		p.Match(MarkdownParserDOUBLE_QUOTE)
	}



	return localctx
}


// IHtmlBlockOpenDivContext is an interface to support dynamic dispatch.
type IHtmlBlockOpenDivContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockOpenDivContext differentiates from other interfaces.
	IsHtmlBlockOpenDivContext()
}

type HtmlBlockOpenDivContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockOpenDivContext() *HtmlBlockOpenDivContext {
	var p = new(HtmlBlockOpenDivContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockOpenDiv
	return p
}

func (*HtmlBlockOpenDivContext) IsHtmlBlockOpenDivContext() {}

func NewHtmlBlockOpenDivContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockOpenDivContext {
	var p = new(HtmlBlockOpenDivContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockOpenDiv

	return p
}

func (s *HtmlBlockOpenDivContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockOpenDivContext) OPEN_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockOpenDivContext) D() antlr.TerminalNode {
	return s.GetToken(MarkdownParserD, 0)
}

func (s *HtmlBlockOpenDivContext) I() antlr.TerminalNode {
	return s.GetToken(MarkdownParserI, 0)
}

func (s *HtmlBlockOpenDivContext) V() antlr.TerminalNode {
	return s.GetToken(MarkdownParserV, 0)
}

func (s *HtmlBlockOpenDivContext) CLOSE_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockOpenDivContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HtmlBlockOpenDivContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HtmlBlockOpenDivContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HtmlBlockOpenDivContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HtmlBlockOpenDivContext) AllHtmlAttributeS() []IHtmlAttributeSContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlAttributeSContext)(nil)).Elem())
	var tst = make([]IHtmlAttributeSContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlAttributeSContext)
		}
	}

	return tst
}

func (s *HtmlBlockOpenDivContext) HtmlAttributeS(i int) IHtmlAttributeSContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlAttributeSContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlAttributeSContext)
}

func (s *HtmlBlockOpenDivContext) AllHtmlAttributeD() []IHtmlAttributeDContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlAttributeDContext)(nil)).Elem())
	var tst = make([]IHtmlAttributeDContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlAttributeDContext)
		}
	}

	return tst
}

func (s *HtmlBlockOpenDivContext) HtmlAttributeD(i int) IHtmlAttributeDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlAttributeDContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlAttributeDContext)
}

func (s *HtmlBlockOpenDivContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockOpenDivContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockOpenDivContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockOpenDiv(s)
	}
}

func (s *HtmlBlockOpenDivContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockOpenDiv(s)
	}
}




func (p *MarkdownParser) HtmlBlockOpenDiv() (localctx IHtmlBlockOpenDivContext) {
	localctx = NewHtmlBlockOpenDivContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, MarkdownParserRULE_htmlBlockOpenDiv)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		p.Match(MarkdownParserOPEN_ANGLE_BRACKET)
	}
	{
		p.SetState(918)
		p.Match(MarkdownParserD)
	}
	{
		p.SetState(919)
		p.Match(MarkdownParserI)
	}
	{
		p.SetState(920)
		p.Match(MarkdownParserV)
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(922)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(921)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


				p.SetState(924)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(928)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(926)
					p.HtmlAttributeS()
				}


			case 2:
				{
					p.SetState(927)
					p.HtmlAttributeD()
				}

			}


		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())
	}
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(935)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(941)
		p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
	}



	return localctx
}


// IHtmlBlockCloseDivContext is an interface to support dynamic dispatch.
type IHtmlBlockCloseDivContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockCloseDivContext differentiates from other interfaces.
	IsHtmlBlockCloseDivContext()
}

type HtmlBlockCloseDivContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockCloseDivContext() *HtmlBlockCloseDivContext {
	var p = new(HtmlBlockCloseDivContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockCloseDiv
	return p
}

func (*HtmlBlockCloseDivContext) IsHtmlBlockCloseDivContext() {}

func NewHtmlBlockCloseDivContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockCloseDivContext {
	var p = new(HtmlBlockCloseDivContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockCloseDiv

	return p
}

func (s *HtmlBlockCloseDivContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockCloseDivContext) OPEN_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockCloseDivContext) SLASH() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSLASH, 0)
}

func (s *HtmlBlockCloseDivContext) D() antlr.TerminalNode {
	return s.GetToken(MarkdownParserD, 0)
}

func (s *HtmlBlockCloseDivContext) I() antlr.TerminalNode {
	return s.GetToken(MarkdownParserI, 0)
}

func (s *HtmlBlockCloseDivContext) V() antlr.TerminalNode {
	return s.GetToken(MarkdownParserV, 0)
}

func (s *HtmlBlockCloseDivContext) CLOSE_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockCloseDivContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HtmlBlockCloseDivContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HtmlBlockCloseDivContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HtmlBlockCloseDivContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HtmlBlockCloseDivContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockCloseDivContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockCloseDivContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockCloseDiv(s)
	}
}

func (s *HtmlBlockCloseDivContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockCloseDiv(s)
	}
}




func (p *MarkdownParser) HtmlBlockCloseDiv() (localctx IHtmlBlockCloseDivContext) {
	localctx = NewHtmlBlockCloseDivContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, MarkdownParserRULE_htmlBlockCloseDiv)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(943)
		p.Match(MarkdownParserOPEN_ANGLE_BRACKET)
	}
	{
		p.SetState(944)
		p.Match(MarkdownParserSLASH)
	}
	{
		p.SetState(945)
		p.Match(MarkdownParserD)
	}
	{
		p.SetState(946)
		p.Match(MarkdownParserI)
	}
	{
		p.SetState(947)
		p.Match(MarkdownParserV)
	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(948)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(953)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(954)
		p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
	}



	return localctx
}


// IHtmlBlockDivContext is an interface to support dynamic dispatch.
type IHtmlBlockDivContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockDivContext differentiates from other interfaces.
	IsHtmlBlockDivContext()
}

type HtmlBlockDivContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockDivContext() *HtmlBlockDivContext {
	var p = new(HtmlBlockDivContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockDiv
	return p
}

func (*HtmlBlockDivContext) IsHtmlBlockDivContext() {}

func NewHtmlBlockDivContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockDivContext {
	var p = new(HtmlBlockDivContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockDiv

	return p
}

func (s *HtmlBlockDivContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockDivContext) HtmlBlockOpenDiv() IHtmlBlockOpenDivContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockOpenDivContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockOpenDivContext)
}

func (s *HtmlBlockDivContext) HtmlBlockCloseDiv() IHtmlBlockCloseDivContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockCloseDivContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockCloseDivContext)
}

func (s *HtmlBlockDivContext) AllHtmlBlockDiv() []IHtmlBlockDivContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlBlockDivContext)(nil)).Elem())
	var tst = make([]IHtmlBlockDivContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlBlockDivContext)
		}
	}

	return tst
}

func (s *HtmlBlockDivContext) HtmlBlockDiv(i int) IHtmlBlockDivContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockDivContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockDivContext)
}

func (s *HtmlBlockDivContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockDivContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockDivContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockDiv(s)
	}
}

func (s *HtmlBlockDivContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockDiv(s)
	}
}




func (p *MarkdownParser) HtmlBlockDiv() (localctx IHtmlBlockDivContext) {
	localctx = NewHtmlBlockDivContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, MarkdownParserRULE_htmlBlockDiv)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.HtmlBlockOpenDiv()
	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(959)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(957)
					p.HtmlBlockDiv()
				}


			case 2:
				p.SetState(958)
				p.MatchWildcard()


			}

		}
		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())
	}
	{
		p.SetState(964)
		p.HtmlBlockCloseDiv()
	}



	return localctx
}


// IHtmlBlockOpenSpanContext is an interface to support dynamic dispatch.
type IHtmlBlockOpenSpanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockOpenSpanContext differentiates from other interfaces.
	IsHtmlBlockOpenSpanContext()
}

type HtmlBlockOpenSpanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockOpenSpanContext() *HtmlBlockOpenSpanContext {
	var p = new(HtmlBlockOpenSpanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockOpenSpan
	return p
}

func (*HtmlBlockOpenSpanContext) IsHtmlBlockOpenSpanContext() {}

func NewHtmlBlockOpenSpanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockOpenSpanContext {
	var p = new(HtmlBlockOpenSpanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockOpenSpan

	return p
}

func (s *HtmlBlockOpenSpanContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockOpenSpanContext) OPEN_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockOpenSpanContext) S() antlr.TerminalNode {
	return s.GetToken(MarkdownParserS, 0)
}

func (s *HtmlBlockOpenSpanContext) P() antlr.TerminalNode {
	return s.GetToken(MarkdownParserP, 0)
}

func (s *HtmlBlockOpenSpanContext) A() antlr.TerminalNode {
	return s.GetToken(MarkdownParserA, 0)
}

func (s *HtmlBlockOpenSpanContext) N() antlr.TerminalNode {
	return s.GetToken(MarkdownParserN, 0)
}

func (s *HtmlBlockOpenSpanContext) CLOSE_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockOpenSpanContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HtmlBlockOpenSpanContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HtmlBlockOpenSpanContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HtmlBlockOpenSpanContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HtmlBlockOpenSpanContext) AllHtmlAttributeS() []IHtmlAttributeSContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlAttributeSContext)(nil)).Elem())
	var tst = make([]IHtmlAttributeSContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlAttributeSContext)
		}
	}

	return tst
}

func (s *HtmlBlockOpenSpanContext) HtmlAttributeS(i int) IHtmlAttributeSContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlAttributeSContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlAttributeSContext)
}

func (s *HtmlBlockOpenSpanContext) AllHtmlAttributeD() []IHtmlAttributeDContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlAttributeDContext)(nil)).Elem())
	var tst = make([]IHtmlAttributeDContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlAttributeDContext)
		}
	}

	return tst
}

func (s *HtmlBlockOpenSpanContext) HtmlAttributeD(i int) IHtmlAttributeDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlAttributeDContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlAttributeDContext)
}

func (s *HtmlBlockOpenSpanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockOpenSpanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockOpenSpanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockOpenSpan(s)
	}
}

func (s *HtmlBlockOpenSpanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockOpenSpan(s)
	}
}




func (p *MarkdownParser) HtmlBlockOpenSpan() (localctx IHtmlBlockOpenSpanContext) {
	localctx = NewHtmlBlockOpenSpanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MarkdownParserRULE_htmlBlockOpenSpan)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(966)
		p.Match(MarkdownParserOPEN_ANGLE_BRACKET)
	}
	{
		p.SetState(967)
		p.Match(MarkdownParserS)
	}
	{
		p.SetState(968)
		p.Match(MarkdownParserP)
	}
	{
		p.SetState(969)
		p.Match(MarkdownParserA)
	}
	{
		p.SetState(970)
		p.Match(MarkdownParserN)
	}
	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(972)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(971)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


				p.SetState(974)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(978)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(976)
					p.HtmlAttributeS()
				}


			case 2:
				{
					p.SetState(977)
					p.HtmlAttributeD()
				}

			}


		}
		p.SetState(984)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext())
	}
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(985)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(990)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(991)
		p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
	}



	return localctx
}


// IHtmlBlockCloseSpanContext is an interface to support dynamic dispatch.
type IHtmlBlockCloseSpanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockCloseSpanContext differentiates from other interfaces.
	IsHtmlBlockCloseSpanContext()
}

type HtmlBlockCloseSpanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockCloseSpanContext() *HtmlBlockCloseSpanContext {
	var p = new(HtmlBlockCloseSpanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockCloseSpan
	return p
}

func (*HtmlBlockCloseSpanContext) IsHtmlBlockCloseSpanContext() {}

func NewHtmlBlockCloseSpanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockCloseSpanContext {
	var p = new(HtmlBlockCloseSpanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockCloseSpan

	return p
}

func (s *HtmlBlockCloseSpanContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockCloseSpanContext) OPEN_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockCloseSpanContext) SLASH() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSLASH, 0)
}

func (s *HtmlBlockCloseSpanContext) S() antlr.TerminalNode {
	return s.GetToken(MarkdownParserS, 0)
}

func (s *HtmlBlockCloseSpanContext) P() antlr.TerminalNode {
	return s.GetToken(MarkdownParserP, 0)
}

func (s *HtmlBlockCloseSpanContext) A() antlr.TerminalNode {
	return s.GetToken(MarkdownParserA, 0)
}

func (s *HtmlBlockCloseSpanContext) N() antlr.TerminalNode {
	return s.GetToken(MarkdownParserN, 0)
}

func (s *HtmlBlockCloseSpanContext) CLOSE_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockCloseSpanContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HtmlBlockCloseSpanContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HtmlBlockCloseSpanContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HtmlBlockCloseSpanContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HtmlBlockCloseSpanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockCloseSpanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockCloseSpanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockCloseSpan(s)
	}
}

func (s *HtmlBlockCloseSpanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockCloseSpan(s)
	}
}




func (p *MarkdownParser) HtmlBlockCloseSpan() (localctx IHtmlBlockCloseSpanContext) {
	localctx = NewHtmlBlockCloseSpanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MarkdownParserRULE_htmlBlockCloseSpan)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.Match(MarkdownParserOPEN_ANGLE_BRACKET)
	}
	{
		p.SetState(994)
		p.Match(MarkdownParserSLASH)
	}
	{
		p.SetState(995)
		p.Match(MarkdownParserS)
	}
	{
		p.SetState(996)
		p.Match(MarkdownParserP)
	}
	{
		p.SetState(997)
		p.Match(MarkdownParserA)
	}
	{
		p.SetState(998)
		p.Match(MarkdownParserN)
	}
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(999)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(1004)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1005)
		p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
	}



	return localctx
}


// IHtmlBlockSpanContext is an interface to support dynamic dispatch.
type IHtmlBlockSpanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockSpanContext differentiates from other interfaces.
	IsHtmlBlockSpanContext()
}

type HtmlBlockSpanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockSpanContext() *HtmlBlockSpanContext {
	var p = new(HtmlBlockSpanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockSpan
	return p
}

func (*HtmlBlockSpanContext) IsHtmlBlockSpanContext() {}

func NewHtmlBlockSpanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockSpanContext {
	var p = new(HtmlBlockSpanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockSpan

	return p
}

func (s *HtmlBlockSpanContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockSpanContext) HtmlBlockOpenSpan() IHtmlBlockOpenSpanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockOpenSpanContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockOpenSpanContext)
}

func (s *HtmlBlockSpanContext) HtmlBlockCloseSpan() IHtmlBlockCloseSpanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockCloseSpanContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockCloseSpanContext)
}

func (s *HtmlBlockSpanContext) AllHtmlBlockSpan() []IHtmlBlockSpanContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlBlockSpanContext)(nil)).Elem())
	var tst = make([]IHtmlBlockSpanContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlBlockSpanContext)
		}
	}

	return tst
}

func (s *HtmlBlockSpanContext) HtmlBlockSpan(i int) IHtmlBlockSpanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockSpanContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockSpanContext)
}

func (s *HtmlBlockSpanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockSpanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockSpanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockSpan(s)
	}
}

func (s *HtmlBlockSpanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockSpan(s)
	}
}




func (p *MarkdownParser) HtmlBlockSpan() (localctx IHtmlBlockSpanContext) {
	localctx = NewHtmlBlockSpanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MarkdownParserRULE_htmlBlockSpan)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1007)
		p.HtmlBlockOpenSpan()
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(1010)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1008)
					p.HtmlBlockSpan()
				}


			case 2:
				p.SetState(1009)
				p.MatchWildcard()


			}

		}
		p.SetState(1014)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
	}
	{
		p.SetState(1015)
		p.HtmlBlockCloseSpan()
	}



	return localctx
}


// IHtmlBlockHrContext is an interface to support dynamic dispatch.
type IHtmlBlockHrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockHrContext differentiates from other interfaces.
	IsHtmlBlockHrContext()
}

type HtmlBlockHrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockHrContext() *HtmlBlockHrContext {
	var p = new(HtmlBlockHrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockHr
	return p
}

func (*HtmlBlockHrContext) IsHtmlBlockHrContext() {}

func NewHtmlBlockHrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockHrContext {
	var p = new(HtmlBlockHrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockHr

	return p
}

func (s *HtmlBlockHrContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockHrContext) OPEN_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockHrContext) H() antlr.TerminalNode {
	return s.GetToken(MarkdownParserH, 0)
}

func (s *HtmlBlockHrContext) R() antlr.TerminalNode {
	return s.GetToken(MarkdownParserR, 0)
}

func (s *HtmlBlockHrContext) CLOSE_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockHrContext) SLASH() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSLASH, 0)
}

func (s *HtmlBlockHrContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HtmlBlockHrContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HtmlBlockHrContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HtmlBlockHrContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HtmlBlockHrContext) AllHtmlAttributeS() []IHtmlAttributeSContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlAttributeSContext)(nil)).Elem())
	var tst = make([]IHtmlAttributeSContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlAttributeSContext)
		}
	}

	return tst
}

func (s *HtmlBlockHrContext) HtmlAttributeS(i int) IHtmlAttributeSContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlAttributeSContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlAttributeSContext)
}

func (s *HtmlBlockHrContext) AllHtmlAttributeD() []IHtmlAttributeDContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlAttributeDContext)(nil)).Elem())
	var tst = make([]IHtmlAttributeDContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlAttributeDContext)
		}
	}

	return tst
}

func (s *HtmlBlockHrContext) HtmlAttributeD(i int) IHtmlAttributeDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlAttributeDContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlAttributeDContext)
}

func (s *HtmlBlockHrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockHrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockHrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockHr(s)
	}
}

func (s *HtmlBlockHrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockHr(s)
	}
}




func (p *MarkdownParser) HtmlBlockHr() (localctx IHtmlBlockHrContext) {
	localctx = NewHtmlBlockHrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MarkdownParserRULE_htmlBlockHr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.Match(MarkdownParserOPEN_ANGLE_BRACKET)
	}
	{
		p.SetState(1018)
		p.Match(MarkdownParserH)
	}
	{
		p.SetState(1019)
		p.Match(MarkdownParserR)
	}
	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1021)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(1020)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


				p.SetState(1023)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(1027)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1025)
					p.HtmlAttributeS()
				}


			case 2:
				{
					p.SetState(1026)
					p.HtmlAttributeD()
				}

			}


		}
		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext())
	}
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1034)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


		}
		p.SetState(1039)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())
	}
	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == MarkdownParserSLASH {
		{
			p.SetState(1040)
			p.Match(MarkdownParserSLASH)
		}

	}
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(1043)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(1048)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1049)
		p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
	}



	return localctx
}


// IHtmlBlockInTagsContext is an interface to support dynamic dispatch.
type IHtmlBlockInTagsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockInTagsContext differentiates from other interfaces.
	IsHtmlBlockInTagsContext()
}

type HtmlBlockInTagsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockInTagsContext() *HtmlBlockInTagsContext {
	var p = new(HtmlBlockInTagsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockInTags
	return p
}

func (*HtmlBlockInTagsContext) IsHtmlBlockInTagsContext() {}

func NewHtmlBlockInTagsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockInTagsContext {
	var p = new(HtmlBlockInTagsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockInTags

	return p
}

func (s *HtmlBlockInTagsContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockInTagsContext) HtmlBlockDiv() IHtmlBlockDivContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockDivContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockDivContext)
}

func (s *HtmlBlockInTagsContext) HtmlBlockSpan() IHtmlBlockSpanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockSpanContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockSpanContext)
}

func (s *HtmlBlockInTagsContext) HtmlBlockHr() IHtmlBlockHrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlBlockHrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlBlockHrContext)
}

func (s *HtmlBlockInTagsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockInTagsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockInTagsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockInTags(s)
	}
}

func (s *HtmlBlockInTagsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockInTags(s)
	}
}




func (p *MarkdownParser) HtmlBlockInTags() (localctx IHtmlBlockInTagsContext) {
	localctx = NewHtmlBlockInTagsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MarkdownParserRULE_htmlBlockInTags)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1051)
			p.HtmlBlockDiv()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1052)
			p.HtmlBlockSpan()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1053)
			p.HtmlBlockHr()
		}

	}


	return localctx
}


// IHtmlBlockInSelfClosingContext is an interface to support dynamic dispatch.
type IHtmlBlockInSelfClosingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlBlockInSelfClosingContext differentiates from other interfaces.
	IsHtmlBlockInSelfClosingContext()
}

type HtmlBlockInSelfClosingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlBlockInSelfClosingContext() *HtmlBlockInSelfClosingContext {
	var p = new(HtmlBlockInSelfClosingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlBlockInSelfClosing
	return p
}

func (*HtmlBlockInSelfClosingContext) IsHtmlBlockInSelfClosingContext() {}

func NewHtmlBlockInSelfClosingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlBlockInSelfClosingContext {
	var p = new(HtmlBlockInSelfClosingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlBlockInSelfClosing

	return p
}

func (s *HtmlBlockInSelfClosingContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlBlockInSelfClosingContext) OPEN_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockInSelfClosingContext) AttributeName() IAttributeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *HtmlBlockInSelfClosingContext) SLASH() antlr.TerminalNode {
	return s.GetToken(MarkdownParserSLASH, 0)
}

func (s *HtmlBlockInSelfClosingContext) CLOSE_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, 0)
}

func (s *HtmlBlockInSelfClosingContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HtmlBlockInSelfClosingContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HtmlBlockInSelfClosingContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HtmlBlockInSelfClosingContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HtmlBlockInSelfClosingContext) AllHtmlAttributeS() []IHtmlAttributeSContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlAttributeSContext)(nil)).Elem())
	var tst = make([]IHtmlAttributeSContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlAttributeSContext)
		}
	}

	return tst
}

func (s *HtmlBlockInSelfClosingContext) HtmlAttributeS(i int) IHtmlAttributeSContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlAttributeSContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlAttributeSContext)
}

func (s *HtmlBlockInSelfClosingContext) AllHtmlAttributeD() []IHtmlAttributeDContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlAttributeDContext)(nil)).Elem())
	var tst = make([]IHtmlAttributeDContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlAttributeDContext)
		}
	}

	return tst
}

func (s *HtmlBlockInSelfClosingContext) HtmlAttributeD(i int) IHtmlAttributeDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlAttributeDContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlAttributeDContext)
}

func (s *HtmlBlockInSelfClosingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlBlockInSelfClosingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlBlockInSelfClosingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlBlockInSelfClosing(s)
	}
}

func (s *HtmlBlockInSelfClosingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlBlockInSelfClosing(s)
	}
}




func (p *MarkdownParser) HtmlBlockInSelfClosing() (localctx IHtmlBlockInSelfClosingContext) {
	localctx = NewHtmlBlockInSelfClosingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MarkdownParserRULE_htmlBlockInSelfClosing)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		p.Match(MarkdownParserOPEN_ANGLE_BRACKET)
	}
	{
		p.SetState(1057)
		p.AttributeName()
	}
	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1059)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
				{
					p.SetState(1058)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


				p.SetState(1061)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(1065)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1063)
					p.HtmlAttributeS()
				}


			case 2:
				{
					p.SetState(1064)
					p.HtmlAttributeD()
				}

			}


		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
	}
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(1072)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1078)
		p.Match(MarkdownParserSLASH)
	}
	{
		p.SetState(1079)
		p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
	}



	return localctx
}


// IHtmlCommentContext is an interface to support dynamic dispatch.
type IHtmlCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlCommentContext differentiates from other interfaces.
	IsHtmlCommentContext()
}

type HtmlCommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlCommentContext() *HtmlCommentContext {
	var p = new(HtmlCommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_htmlComment
	return p
}

func (*HtmlCommentContext) IsHtmlCommentContext() {}

func NewHtmlCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlCommentContext {
	var p = new(HtmlCommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_htmlComment

	return p
}

func (s *HtmlCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlCommentContext) HTML_COMMENT_OPEN() antlr.TerminalNode {
	return s.GetToken(MarkdownParserHTML_COMMENT_OPEN, 0)
}

func (s *HtmlCommentContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserMINUS)
}

func (s *HtmlCommentContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserMINUS, i)
}

func (s *HtmlCommentContext) CLOSE_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, 0)
}

func (s *HtmlCommentContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(MarkdownParserNEWLINE, 0)
}

func (s *HtmlCommentContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(MarkdownParserLINE_BREAK, 0)
}

func (s *HtmlCommentContext) AllSPACE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserSPACE)
}

func (s *HtmlCommentContext) SPACE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserSPACE, i)
}

func (s *HtmlCommentContext) AllTAB() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserTAB)
}

func (s *HtmlCommentContext) TAB(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserTAB, i)
}

func (s *HtmlCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HtmlCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterHtmlComment(s)
	}
}

func (s *HtmlCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitHtmlComment(s)
	}
}




func (p *MarkdownParser) HtmlComment() (localctx IHtmlCommentContext) {
	localctx = NewHtmlCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MarkdownParserRULE_htmlComment)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1081)
		p.Match(MarkdownParserHTML_COMMENT_OPEN)
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(1082)
			p.MatchWildcard()



		}
		p.SetState(1087)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}
	{
		p.SetState(1088)
		p.Match(MarkdownParserMINUS)
	}
	{
		p.SetState(1089)
		p.Match(MarkdownParserMINUS)
	}
	{
		p.SetState(1090)
		p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
	}
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == MarkdownParserSPACE || _la == MarkdownParserTAB {
		{
			p.SetState(1091)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MarkdownParserSPACE || _la == MarkdownParserTAB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(1096)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1097)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MarkdownParserLINE_BREAK || _la == MarkdownParserNEWLINE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IAutolinkContext is an interface to support dynamic dispatch.
type IAutolinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAutolinkContext differentiates from other interfaces.
	IsAutolinkContext()
}

type AutolinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAutolinkContext() *AutolinkContext {
	var p = new(AutolinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MarkdownParserRULE_autolink
	return p
}

func (*AutolinkContext) IsAutolinkContext() {}

func NewAutolinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AutolinkContext {
	var p = new(AutolinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MarkdownParserRULE_autolink

	return p
}

func (s *AutolinkContext) GetParser() antlr.Parser { return s.parser }

func (s *AutolinkContext) OPEN_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(MarkdownParserOPEN_ANGLE_BRACKET, 0)
}

func (s *AutolinkContext) AllCLOSE_ANGLE_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserCLOSE_ANGLE_BRACKET)
}

func (s *AutolinkContext) CLOSE_ANGLE_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserCLOSE_ANGLE_BRACKET, i)
}

func (s *AutolinkContext) AllBLANK_LINE() []antlr.TerminalNode {
	return s.GetTokens(MarkdownParserBLANK_LINE)
}

func (s *AutolinkContext) BLANK_LINE(i int) antlr.TerminalNode {
	return s.GetToken(MarkdownParserBLANK_LINE, i)
}

func (s *AutolinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutolinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AutolinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.EnterAutolink(s)
	}
}

func (s *AutolinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MarkdownParserListener); ok {
		listenerT.ExitAutolink(s)
	}
}




func (p *MarkdownParser) Autolink() (localctx IAutolinkContext) {
	localctx = NewAutolinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MarkdownParserRULE_autolink)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.Match(MarkdownParserOPEN_ANGLE_BRACKET)
	}
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << MarkdownParserSPACE) | (1 << MarkdownParserTAB) | (1 << MarkdownParserEMPH) | (1 << MarkdownParserMINUS) | (1 << MarkdownParserUNDERSCORE) | (1 << MarkdownParserOPEN_PAREN) | (1 << MarkdownParserCLOSE_PAREN) | (1 << MarkdownParserOPEN_SB) | (1 << MarkdownParserCLOSE_SB) | (1 << MarkdownParserDOUBLE_QUOTE) | (1 << MarkdownParserSINGLE_QUOTE) | (1 << MarkdownParserCOLON) | (1 << MarkdownParserSEMI_COLON) | (1 << MarkdownParserAT) | (1 << MarkdownParserEXCLAMATION_MARK) | (1 << MarkdownParserHTML_COMMENT_OPEN) | (1 << MarkdownParserSLASH) | (1 << MarkdownParserPERIOD) | (1 << MarkdownParserEQUAL) | (1 << MarkdownParserAMPERSAND) | (1 << MarkdownParserBACKSLASH) | (1 << MarkdownParserBACKTICK) | (1 << MarkdownParserPLUS) | (1 << MarkdownParserOPEN_CURLY) | (1 << MarkdownParserCLOSE_CURLY) | (1 << MarkdownParserD) | (1 << MarkdownParserI) | (1 << MarkdownParserV) | (1 << MarkdownParserS) | (1 << MarkdownParserP))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (MarkdownParserA - 32)) | (1 << (MarkdownParserN - 32)) | (1 << (MarkdownParserH - 32)) | (1 << (MarkdownParserR - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_1 - 32)) | (1 << (MarkdownParserSETEXT_BOTTOM_2 - 32)) | (1 << (MarkdownParserATX_START - 32)) | (1 << (MarkdownParserSHARP - 32)) | (1 << (MarkdownParserLINE_BREAK - 32)) | (1 << (MarkdownParserNEWLINE - 32)) | (1 << (MarkdownParserHEX_CHAR - 32)) | (1 << (MarkdownParserNORMAL_CHAR - 32)) | (1 << (MarkdownParserDIGIT - 32)) | (1 << (MarkdownParserOPEN_ANGLE_BRACKET - 32)) | (1 << (MarkdownParserSPECIAL_CHAR - 32)))) != 0) {
		{
			p.SetState(1100)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MarkdownParserCLOSE_ANGLE_BRACKET || _la == MarkdownParserBLANK_LINE  {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


		p.SetState(1103)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1105)
		p.Match(MarkdownParserCLOSE_ANGLE_BRACKET)
	}



	return localctx
}


func (p *MarkdownParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 1:
			var t *BlockContext = nil
			if localctx != nil { t = localctx.(*BlockContext) }
			return p.Block_Sempred(t, predIndex)

	case 6:
			var t *SetextHeading1Context = nil
			if localctx != nil { t = localctx.(*SetextHeading1Context) }
			return p.SetextHeading1_Sempred(t, predIndex)

	case 7:
			var t *SetextHeading2Context = nil
			if localctx != nil { t = localctx.(*SetextHeading2Context) }
			return p.SetextHeading2_Sempred(t, predIndex)

	case 11:
			var t *BlockQuoteContext = nil
			if localctx != nil { t = localctx.(*BlockQuoteContext) }
			return p.BlockQuote_Sempred(t, predIndex)

	case 13:
			var t *VerbatimContext = nil
			if localctx != nil { t = localctx.(*VerbatimContext) }
			return p.Verbatim_Sempred(t, predIndex)

	case 25:
			var t *OrderedListContext = nil
			if localctx != nil { t = localctx.(*OrderedListContext) }
			return p.OrderedList_Sempred(t, predIndex)

	case 26:
			var t *BulletListContext = nil
			if localctx != nil { t = localctx.(*BulletListContext) }
			return p.BulletList_Sempred(t, predIndex)

	case 27:
			var t *OrderedListItemContext = nil
			if localctx != nil { t = localctx.(*OrderedListItemContext) }
			return p.OrderedListItem_Sempred(t, predIndex)

	case 28:
			var t *BulletListItemContext = nil
			if localctx != nil { t = localctx.(*BulletListItemContext) }
			return p.BulletListItem_Sempred(t, predIndex)

	case 29:
			var t *InlineListItemContext = nil
			if localctx != nil { t = localctx.(*InlineListItemContext) }
			return p.InlineListItem_Sempred(t, predIndex)

	case 35:
			var t *EmphStarContext = nil
			if localctx != nil { t = localctx.(*EmphStarContext) }
			return p.EmphStar_Sempred(t, predIndex)

	case 36:
			var t *EmphUlContext = nil
			if localctx != nil { t = localctx.(*EmphUlContext) }
			return p.EmphUl_Sempred(t, predIndex)

	case 38:
			var t *StrongStarContext = nil
			if localctx != nil { t = localctx.(*StrongStarContext) }
			return p.StrongStar_Sempred(t, predIndex)

	case 39:
			var t *StrongUlContext = nil
			if localctx != nil { t = localctx.(*StrongUlContext) }
			return p.StrongUl_Sempred(t, predIndex)

	case 59:
			var t *BacktickCodeContext = nil
			if localctx != nil { t = localctx.(*BacktickCodeContext) }
			return p.BacktickCode_Sempred(t, predIndex)

	case 60:
			var t *DoubleBacktickCodeContext = nil
			if localctx != nil { t = localctx.(*DoubleBacktickCodeContext) }
			return p.DoubleBacktickCode_Sempred(t, predIndex)

	case 61:
			var t *SpaceBacktickCodeContext = nil
			if localctx != nil { t = localctx.(*SpaceBacktickCodeContext) }
			return p.SpaceBacktickCode_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MarkdownParser) Block_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return followListItem(1, 0)

	case 1:
			return followListItem(1, 0)

	case 2:
			return followVerbatim(0)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) SetextHeading1_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
			return !tokenIs(1, NEWLINE)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) SetextHeading2_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
			return !tokenIs(1, NEWLINE)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) BlockQuote_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
			return followBlockquote(localctx.(*BlockQuoteContext)._level)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) Verbatim_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
			return followVerbatim(localctx.(*VerbatimContext)._level, true)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) OrderedList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
			return followListItem(1, localctx.(*OrderedListContext)._level, true)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) BulletList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
			return followListItem(1, localctx.(*BulletListContext)._level, true)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) OrderedListItem_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
			return followListItem(1, localctx.(*OrderedListItemContext)._level+1)

	case 10:
			return followVerbatim(localctx.(*OrderedListItemContext)._level+1, true) || followListItem(1, localctx.(*OrderedListItemContext)._level+1, true) || followContinuation(localctx.(*OrderedListItemContext)._level, true)

	case 11:
			return followVerbatim(localctx.(*OrderedListItemContext)._level+1, true)

	case 12:
			return followListItem(1, localctx.(*OrderedListItemContext)._level+1, true)

	case 13:
			return followBlockquote(localctx.(*OrderedListItemContext)._level+1)

	case 14:
			return followContinuation(localctx.(*OrderedListItemContext)._level, true)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) BulletListItem_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
			return followListItem(1, localctx.(*BulletListItemContext)._level+1)

	case 16:
			return followVerbatim(localctx.(*BulletListItemContext)._level+1, true) || followListItem(1, localctx.(*BulletListItemContext)._level+1, true) || followContinuation(localctx.(*BulletListItemContext)._level, true)

	case 17:
			return followVerbatim(localctx.(*BulletListItemContext)._level+1, true)

	case 18:
			return followListItem(1, localctx.(*BulletListItemContext)._level+1, true)

	case 19:
			return followBlockquote(localctx.(*BulletListItemContext)._level+1)

	case 20:
			return followContinuation(localctx.(*BulletListItemContext)._level, true)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) InlineListItem_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 21:
			return !followListItem(1, localctx.(*InlineListItemContext)._level) && !followListItem(1, localctx.(*InlineListItemContext)._level-1) && !followListItem(1, localctx.(*InlineListItemContext)._level+1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) EmphStar_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 22:
			return !tokenStartsWith(2, " ") && !tokenIs(2, EMPH)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) EmphUl_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 23:
			return !tokenStartsWith(2, " ") && !tokenIs(2, UNDERSCORE)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) StrongStar_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 24:
			return !tokenStartsWith(3, " ")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) StrongUl_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 25:
			return !tokenStartsWith(3, " ")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) BacktickCode_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 26:
			return !tokenIs(2, BACKTICK)

	case 27:
			return !tokenIs(1, BLANK_LINE)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) DoubleBacktickCode_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 28:
			return !tokenIs(3, SPACE) && !tokenIs(3, TAB)

	case 29:
			return !tokenIs(1, BLANK_LINE)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MarkdownParser) SpaceBacktickCode_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 30:
			return !tokenIs(1, BLANK_LINE)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

